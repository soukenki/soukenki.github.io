{"meta":{"title":"ITノート屋","subtitle":"","description":"当サイトでは、IT技術の理解や活用など情報の提供を目指しています。","author":"Skk","url":"https://soukenki.github.io","root":"/"},"pages":[{"title":"ホーム","date":"2022-11-18T16:54:27.000Z","updated":"2022-11-22T12:46:31.011Z","comments":true,"path":"categories/index.html","permalink":"https://soukenki.github.io/categories/index.html","excerpt":"","text":""},{"title":"このサイトのついて","date":"2022-11-22T10:39:30.000Z","updated":"2022-11-29T04:48:23.527Z","comments":true,"path":"about/index.html","permalink":"https://soukenki.github.io/about/index.html","excerpt":"","text":"こんにちは。ソウ ケンキと申します。今大学の三年生です。C&#x2F;C++、Linuxなど勉強しています。 当サイトでは、IT技術の理解や活用など情報の提供を目指しています。 メール：&#97;&#x31;&#x31;&#48;&#54;&#54;&#x37;&#49;&#x35;&#x32;&#x38;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;もし、何かアドバイスや質問があれば、ぜひメール・LineやWeChatで連絡してください。 ありがとうございましたよろしくお願いいたします。 （検索機能に関する注意: 最初に検索して記事を見つけます。特定のテキストの場所には Ctrl + f のブラウザー機能を使用してください）"},{"title":"タグ","date":"2022-11-18T16:57:58.000Z","updated":"2022-11-29T04:49:16.431Z","comments":true,"path":"tags/index.html","permalink":"https://soukenki.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"データ構造-双方向循環リスト番兵ノードつけ","slug":"データ構造-双方向循環リスト番兵ノードつけ","date":"2022-12-30T14:46:00.000Z","updated":"2023-01-17T17:48:53.488Z","comments":true,"path":"2022/12/30/データ構造-双方向循環リスト番兵ノードつけ/","link":"","permalink":"https://soukenki.github.io/2022/12/30/%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0-%E5%8F%8C%E6%96%B9%E5%90%91%E5%BE%AA%E7%92%B0%E3%83%AA%E3%82%B9%E3%83%88%E7%95%AA%E5%85%B5%E3%83%8E%E3%83%BC%E3%83%89%E3%81%A4%E3%81%91/","excerpt":"本文章については、Cプログラミングで双方向循環リストを実現し、また番兵ノードもつける。双方向循環リストにおける概念や運用などを明らかに述べることである。目次 &gt; 概念と構造 双方向循環リストの実現 動的ようにノードを生成 出力関数（テスト用） 尾にデータを挿入 ヘッドにデータを挿入 尾にデータを削除 ヘッドにデータを削除 pos位置の後ろにデータを挿入 pos位置の後ろにデータを削除 データの検索 双方向循環リストの破壊 単方向リストとの違い点 メリット デメリット","text":"本文章については、Cプログラミングで双方向循環リストを実現し、また番兵ノードもつける。双方向循環リストにおける概念や運用などを明らかに述べることである。目次 &gt; 概念と構造 双方向循環リストの実現 動的ようにノードを生成 出力関数（テスト用） 尾にデータを挿入 ヘッドにデータを挿入 尾にデータを削除 ヘッドにデータを削除 pos位置の後ろにデータを挿入 pos位置の後ろにデータを削除 データの検索 双方向循環リストの破壊 単方向リストとの違い点 メリット デメリット 名称 データタイプ サイズ 1内容 概念と構造双方向循環リスト番兵ノードつけ: 構造は単方向リストよりも複雑で、通常はデータを個別に格納するために使用されます。 実際に使用される連結リストのデータ構造は、リードを持つ双方向の循環連結リストです。 さらに、構造は複雑ですが、コードを使用して実装すると、構造が多くの利点をもたらし、実装が簡単であることがわかります。後でコードを実装するときにご覧ください。 双方向循環リスト番兵ノードつけ ノードの本体 ノードなしの時 双方向循環リストの実現返されたリンク リストのヘッド ノードを作成する。(連結リストの初期化) 1234567LTNode* ListInit()&#123; LTNode* phead = BuyListNode(-1); // ヘッドノードに -1 を入れる phead-&gt;_prev = phead; // すべてが番兵ノードの自分自身を指している phead-&gt;_next = phead; return phead;&#125; 動的ようにノードを生成12345678910111213LTNode* BuyListNode(LTDataType x)&#123; LTNode* node = (LTNode*)malloc(sizeof(LTNode)); if (node == NULL) &#123; printf(&quot;malloc fail\\n&quot;); exit(-1); &#125; node-&gt;_data = x; node-&gt;_next = NULL; node-&gt;_prev = NULL; return node;&#125; 出力関数（テスト用）123456789101112void ListPrint(LTNode* phead)&#123; assert(phead); LTNode* cur = phead-&gt;_next; while (cur != phead) &#123; printf(&quot;%d &quot;, cur-&gt;_data); cur = cur-&gt;_next; &#125; printf(&quot;\\n&quot;);&#125; 尾にデータを挿入12345678910111213void ListPushBack(LTNode* phead, LTDataType x)&#123; assert(phead); ListInsert(phead, x); // 再利用 //LTNode* newnode = BuyListNode(x); //LTNode* tail = phead-&gt;_prev; //tail-&gt;_next = newnode; //newnode-&gt;_prev = tail; //newnode-&gt;_next = phead; //phead-&gt;_prev = newnode;&#125; ヘッドにデータを挿入1234567891011121314void ListPushFront(LTNode* phead, LTDataType x)&#123; assert(phead); ListInsert(phead-&gt;_next, x); // 再利用 //LTNode* newnode = BuyListNode(x); //LTNode* next = phead-&gt;_next; //phead-&gt;_next = newnode; //newnode-&gt;_next = next; //next-&gt;_prev = newnode; //newnode-&gt;_prev = phead;&#125; 尾にデータを削除123456789101112131415void ListPopBack(LTNode* phead)&#123; assert(phead); assert(!ListEmpty(phead)); // リストが空でない場合にしか続行しない ListErase(phead-&gt;_prev); //LTNode* tail = phead-&gt;_prev; //LTNode* tailPrev = tail-&gt;_prev; //free(tail); //tailPrev-&gt;_next = phead; //phead-&gt;_prev = tailPrev;&#125; ヘッドにデータを削除123456void ListPopFront(LTNode* phead)&#123; assert(phead); assert(!ListEmpty(phead));// リストが空でない場合にしか続行しない ListErase(phead-&gt;_next); // 再利用&#125; pos位置の前にデータを挿入123456789101112void ListInsert(LTNode* pos, LTDataType x)&#123; assert(pos); LTNode* prev = pos-&gt;_prev; LTNode* newnode = BuyListNode(x); prev-&gt;_next = newnode; newnode-&gt;_prev = prev; newnode-&gt;_next = pos; pos-&gt;_prev = newnode;&#125; pos位置にデータを削除12345678910void ListErase(LTNode* pos)&#123; assert(pos); LTNode* prve = pos-&gt;_prev; LTNode* next = pos-&gt;_next; prve-&gt;_next = next; next-&gt;_prev = prve; free(pos);&#125; データの検索123456789101112131415LTNode* ListFind(LTNode* phead, LTDataType x)&#123; assert(phead); LTNode* cur = phead-&gt;_next; while (cur != phead) &#123; if (cur-&gt;_data == x) return cur; // それを見つけた else cur = cur-&gt;_next; &#125; return NULL; // 見つけていない&#125; 双方向循環リストの破壊12345678910111213141516void ListDestory(LTNode* phead)&#123; assert(phead); LTNode* cur = phead-&gt;_next; while (cur != phead) // phead だけ残ったら終了 &#123; LTNode* next = cur-&gt;_next; // ループ内のすべてのノードを解放する free(cur); cur = next; &#125; free(phead); phead = NULL; printf(&quot;破壊成功\\n&quot;);&#125; 単方向リストとの違い点 メリット デメリット 参考文献 https://github.com/soukenki/Test_for_C/tree/master/test_list2","categories":[{"name":"データ構造とアルゴリズム","slug":"データ構造とアルゴリズム","permalink":"https://soukenki.github.io/categories/%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%E3%81%A8%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/"}],"tags":[{"name":"C言語","slug":"C言語","permalink":"https://soukenki.github.io/tags/C%E8%A8%80%E8%AA%9E/"},{"name":"データ構造とアルゴリズム","slug":"データ構造とアルゴリズム","permalink":"https://soukenki.github.io/tags/%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%E3%81%A8%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/"}]},{"title":"データ構造-単方向リスト","slug":"データ構造-単方向リスト","date":"2022-12-09T17:00:55.000Z","updated":"2023-01-17T15:48:50.756Z","comments":true,"path":"2022/12/10/データ構造-単方向リスト/","link":"","permalink":"https://soukenki.github.io/2022/12/10/%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0-%E5%8D%98%E6%96%B9%E5%90%91%E3%83%AA%E3%82%B9%E3%83%88/","excerpt":"本文章については、Cプログラミングで単方向リストを実現し、単方向リストにおける概念や運用などを明らかに述べることである。目次 &gt; 概念と構造 単方向リストの実現 動的ように要素を生成 出力関数（テスト用） 尾にデータを挿入 ヘッドにデータを挿入 尾にデータを削除 ヘッドにデータを削除 pos位置の後ろにデータを挿入 pos位置の後ろにデータを削除 データの検索 単方向リストの破壊","text":"本文章については、Cプログラミングで単方向リストを実現し、単方向リストにおける概念や運用などを明らかに述べることである。目次 &gt; 概念と構造 単方向リストの実現 動的ように要素を生成 出力関数（テスト用） 尾にデータを挿入 ヘッドにデータを挿入 尾にデータを削除 ヘッドにデータを削除 pos位置の後ろにデータを挿入 pos位置の後ろにデータを削除 データの検索 単方向リストの破壊 - 概念と構造リストとは、配列のようなもので、なかに複数のデータを入れることができますが、リストと配列の違いところもあります。リスト構造のうち、特に要素一つ一つがリンクによって接続されているものを、 「ノード」 と呼びます。 配列はメモリ内の空間は連続していますが、リストはメモリ内の空間は連続していなくてもかまいません。配列は、ノードにデータがしかありません。一方、リストは、ノードにデータを格納するほかに次のノードのポインタが格納されています。リストは、自分のノード内のポインタを介して次のノードの位置を探します。 各ノードは 「データ部」 と 「ポインタ部」 の２つから構成されます。 「ポインタ部」 を辿ることによって次のノードの 「データ部」 にアクセスできます。 ノード構造体12345typedef struct SListNode&#123; SLTDateType data; // データ struct SListNode* next; // 次のノード &#125;SListNode; 単方向リストの実現 動的ように要素を生成12345678SListNode* BuySListNode(SLTDateType x)&#123; SListNode* ret = (SListNode*)malloc(sizeof(SListNode)); assert(ret); ret-&gt;data = x; ret-&gt;next = NULL; return ret;&#125; 出力関数（テスト用）出力関数1234567891011void SListPrint(SListNode* plist)&#123; assert(plist); SListNode* tail = plist; while (tail) &#123; printf(&quot;%d-&gt;&quot;, tail-&gt;data); tail = tail-&gt;next; &#125; printf(&quot;NULL\\n&quot;);&#125; 尾にデータを挿入 123456789101112void SListPushBack(SListNode** pplist, SLTDateType x)&#123; assert(*pplist); SListNode* p = BuySListNode(x); SListNode* tail = *pplist; while (tail-&gt;next != NULL) &#123; tail = tail-&gt;next; &#125; tail-&gt;next = p;&#125; ヘッドにデータを挿入 1234567void SListPushFront(SListNode** pplist, SLTDateType x)&#123; assert(*pplist); SListNode* p = BuySListNode(x); p-&gt;next = *pplist; *pplist = p;&#125; 尾にデータを削除 123456789101112131415161718void SListPopBack(SListNode** pplist)&#123; assert(*pplist); if ((*pplist)-&gt;next == NULL) &#123; free(*pplist); *pplist = NULL; return; &#125; SListNode* tail = *pplist; while (tail-&gt;next-&gt;next != NULL) &#123; tail = tail-&gt;next; &#125; free(tail-&gt;next); tail-&gt;next = NULL;&#125; ヘッドにデータを削除 123456789101112131415void SListPopFront(SListNode** pplist)&#123; assert(*pplist); if ((*pplist)-&gt;next == NULL) &#123; free(*pplist); *pplist = NULL; return; &#125; SListNode* pre = *pplist; *pplist = (*pplist)-&gt;next; free(pre); pre = NULL;&#125; pos位置の後ろにデータを挿入 1234567891011void SListInsertAfter(SListNode* pos, SLTDateType x)&#123; assert(pos); SListNode* newnode = BuySListNode(x); // xの値で新しいノードを動的に申請する SListNode* next = pos-&gt;next; pos-&gt;next = newnode; newnode-&gt;next = next;&#125; pos位置の後ろにデータを削除 12345678910111213141516void SListEraseAfter(SListNode* pos)&#123; assert(pos); if (pos-&gt;next == NULL) &#123; printf(&quot;posの後ろにデータがない\\n&quot;); return; &#125; else &#123; SListNode* next = pos-&gt;next-&gt;next; free(pos-&gt;next); pos-&gt;next = next; &#125;&#125; データの検索1234567891011121314SListNode* SListFind(SListNode* plist, SLTDateType x)&#123; assert(plist); while (plist != NULL) &#123; if (plist-&gt;data == x) &#123; return plist; &#125; plist = plist-&gt;next; &#125; return NULL;&#125; 単方向リストの破壊123456789101112void SListDestory(SListNode* plist)&#123; assert(plist); while (plist) // plistがNULLの場合は終了 &#123; SListNode* next = plist-&gt;next; // 全ノードをループ解放 free(plist); plist = next; &#125; printf(&quot;データの破壊が成功した\\n&quot;);&#125; 次の投稿は、単方向リストに基づいて、「双方向循環リスト番兵ノードつけ」というデータ構造である。興味があれば、是非マイgithubをフォローしてくださいね。(笑) 参考文献 https://github.com/soukenki/Test_for_C/tree/master/test_list","categories":[{"name":"データ構造とアルゴリズム","slug":"データ構造とアルゴリズム","permalink":"https://soukenki.github.io/categories/%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%E3%81%A8%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/"}],"tags":[{"name":"C言語","slug":"C言語","permalink":"https://soukenki.github.io/tags/C%E8%A8%80%E8%AA%9E/"},{"name":"データ構造とアルゴリズム","slug":"データ構造とアルゴリズム","permalink":"https://soukenki.github.io/tags/%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%E3%81%A8%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/"}]},{"title":"データ構造-可変長配列","slug":"データ構造-可変長配列","date":"2022-12-09T11:29:26.000Z","updated":"2022-12-09T14:33:40.959Z","comments":true,"path":"2022/12/09/データ構造-可変長配列/","link":"","permalink":"https://soukenki.github.io/2022/12/09/%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0-%E5%8F%AF%E5%A4%89%E9%95%B7%E9%85%8D%E5%88%97/","excerpt":"本文章については、Cプログラミングで可変長配列を実現し、可変長配列における概念などを明らかに述べることである。目次 &gt; 概念と構造 可変長配列の実現 初期化 尾にデータを挿入 ヘッドにデータを挿入 尾にデータを削除 ヘッドにデータを削除 任意の位置にデータを挿入 任意の位置にデータを削除 データの検索 データの修正 データの破壊 コードの要約 Test.c SeqList.c SeqList.h","text":"本文章については、Cプログラミングで可変長配列を実現し、可変長配列における概念などを明らかに述べることである。目次 &gt; 概念と構造 可変長配列の実現 初期化 尾にデータを挿入 ヘッドにデータを挿入 尾にデータを削除 ヘッドにデータを削除 任意の位置にデータを挿入 任意の位置にデータを削除 データの検索 データの修正 データの破壊 コードの要約 Test.c SeqList.c SeqList.h 概念と構造配列は、データ要素が連続した物理アドレスを持つ記憶ユニットに順次格納される線形構造であり、一般に配列に格納される。 配列の中にデータを追加、削除、検索、変更など実現できる。 配列は、一般に次のように分類ができる： 固定サイズ配列: コンパイル時に長さが決定される配列データ構造である。 動的配列（可変長配列）: コンパイル時ではなく実行時に長さが決定される自動記憶期間の配列データ構造である。 普通の配列は固定長であるため、配列が小さすぎて十分ではない、配列が大きすぎてスペースを浪費しない、様々なの問題がある。そのため、通常は可変長配列を使用する。 次に、可変長配列の実装について説明していきたいと思うよ。 可変長配列の実現まず、プロジェクトを作成し、ヘッダーファイル「SeqList.h」を定義して、関連する関数などを宣言する。 次に、ソースファイル「SeqList.c」を定義して関数の定義を実装し、配列をテストするために、「Test.c」を定義する。 SeqList.h12345678// 動的配列の構造typedef int SLDateType;typedef struct SeqList&#123; SLDateType* _a; // 動的配列へのポインター size_t _size; // データサイズ size_t _capacity; // 容量サイズ&#125;SeqList; 初期化データを操作する前にデータを初期化する必要があるので、まずデータを初期化する関数「SeqListInit」を定義する。 1234567void SeqListInit(SeqList* ps) // 初期化&#123; assert(ps); ps-&gt;_a = NULL; ps-&gt;_size = 0; ps-&gt;_capacity = 0; &#125; 尾にデータを挿入初期化後、シーケンス テーブルの最初の関数を実装します。配列の最後にデータを挿入します。 ただし、データを挿入する前に、配列にデータがあるかどうか、またはデータが多すぎて拡張する必要があるかどうかを判断する必要があります。他の機能についても、実装前にこのように判断する必要がありますが、ここでは、この機能は機能によって実現されています。 拡張の必要を判断12345678910111213141516171819void SeqListCheckCapacity(SeqList* ps) // 容量サイズを検査&#123; assert(ps); if (ps-&gt;_size == ps-&gt;_capacity) &#123; int newCapacity = ps-&gt;_capacity == 0 ? 4 : ps-&gt;_capacity * 2; // はじめに4を設定，以降毎回*2 SLDateType* tmp = (SLDateType*)realloc(ps-&gt;_a, newCapacity * sizeof(SLDateType)); if (tmp == NULL) &#123; printf(&quot;realloc : fail\\n&quot;); exit(-1); &#125; // 更新する ps-&gt;_a = tmp; tmp = NULL; ps-&gt;_capacity = newCapacity; &#125;&#125; 尾に挿入12345678void SeqListPushBack(SeqList* ps, SLDateType x) &#123; assert(ps); SeqListCheckCapacity(ps);// 容量サイズを検査 ps-&gt;a[ps-&gt;size] = x; ps-&gt;size++;&#125; ヘッドにデータを挿入 1234567891011121314151617void SeqListPushFront(SeqList* ps, SLDateType x) &#123; assert(ps); SeqListCheckCapacity(ps);// 容量サイズを検査 if (ps-&gt;_size &gt; 0) // ヘッドのデータを移動 &#123; int end = ps-&gt;_size - 1; while (end &gt;= 0) // 尾+1のところ &#123; ps-&gt;_a[end + 1] = ps-&gt;_a[end]; --end; &#125; &#125; ps-&gt;_sizeof++; ps-&gt;_a[0]=x;&#125; 尾にデータを削除 1234567void SeqListPopBack(SeqList* ps) &#123; assert(ps); assert(ps-&gt;_size &gt; 0); ps-&gt;_size--; // データ数を直接 1 減らす&#125; ヘッドにデータを削除 123456789101112131415void SeqListPopBack(SeqList* ps) &#123; assert(ps != NULL); assert(ps-&gt;size &gt; 0); int begin = 1; while (begin &lt; ps-&gt;size) &#123; ps-&gt;a[begin - 1] = ps-&gt;a[begin]; ++begin; &#125; ps-&gt;size--;&#125; 任意の位置にデータを挿入 123456789101112131415161718// 位置 pos に データを挿入void SeqListInsert(SeqList* ps, size_t pos, SLDateType x)&#123; assert(ps); assert(pos &gt;= 0 &amp;&amp; pos &lt;= ps-&gt;_size); SeqListCheckCapacity(ps);// 容量サイズを検査 int end = ps-&gt;_size - 1; while (end &gt;= pos &amp;&amp; end &gt;= 0) // 尾+1のところ &#123; ps-&gt;_a[end + 1] = ps-&gt;_a[end]; --end; &#125; ps-&gt;_a[pos] = x; ps-&gt;_size++;&#125; 任意の位置にデータを削除 12345678910111213141516171819202122// 位置 pos に データを削除void SeqListErase(SeqList* ps, size_t pos)&#123; assert(ps); assert(pos &gt;= 0 &amp;&amp; pos &lt; ps-&gt;_size); if (pos == ps-&gt;_size - 1) &#123; ps-&gt;_size--; return; &#125; else &#123; int begin = pos + 1; // pos=0 の場合、範囲外のアクセスを防止する while (begin &lt; ps-&gt;_size) &#123; ps-&gt;_a[begin - 1] = ps-&gt;_a[begin]; begin++; &#125; ps-&gt;_size--; &#125;&#125; データの検索12345678910int SeqListFind(SeqList* ps, SLDateType x)&#123; assert(ps); for (int i = 0; i &lt; ps-&gt;_size; ++i) &#123; if (ps-&gt;_a[i] == x) return i; &#125; return -1;&#125; データの修正12345678// パラメータ pos を最初に検索する必要があるvoid SeqListModify(SeqList* ps, int pos, SLDateType x) &#123; assert(ps); assert(pos &gt;= 0 &amp;&amp; pos &lt; ps-&gt;_size); ps-&gt;_a[pos] = x;&#125; データの破壊12345678910111213void SeqListDestroy(SeqList* ps)&#123; assert(ps); if (ps-&gt;_a) &#123; free(ps-&gt;_a); ps-&gt;_a = NULL; ps-&gt;_size = 0; ps-&gt;_capacity = 0; printf(&quot;データの破壊が成功した\\n&quot;); &#125;&#125; コードの要約 Test.c123456789101112#include&quot;SeqList.h&quot; void testSeqList()&#123; //...テストする&#125; int main()&#123; testSeqList(); return 0;&#125; SeqList.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#define _CRT_SECURE_NO_WARNINGS 1#include &quot;SeqList.h&quot;void SeqListInit(SeqList* ps) // 初期化&#123; assert(ps); ps-&gt;_a = NULL; ps-&gt;_size = 0; ps-&gt;_capacity = 0;&#125;void SeqListCheckCapacity(SeqList* ps) // 容量サイズを検査&#123; assert(ps); if (ps-&gt;_size == ps-&gt;_capacity) &#123; int newCapacity = ps-&gt;_capacity == 0 ? 4 : ps-&gt;_capacity * 2; // はじめに4を設定，以降毎回*2 SLDateType* tmp = (SLDateType*)realloc(ps-&gt;_a, newCapacity * sizeof(SLDateType)); if (tmp == NULL) &#123; printf(&quot;realloc : fail\\n&quot;); exit(-1); &#125; // 更新する ps-&gt;_a = tmp; tmp = NULL; ps-&gt;_capacity = newCapacity; &#125;&#125;void SeqListDestroy(SeqList* ps) // データの破壊&#123; assert(ps); if (ps-&gt;_a) &#123; free(ps-&gt;_a); ps-&gt;_a = NULL; ps-&gt;_size = 0; ps-&gt;_capacity = 0; printf(&quot;データの破壊が成功した\\n&quot;); &#125;&#125;void SeqListPrint(SeqList* ps) // 出力関数&#123; assert(ps); for (int i = 0; i &lt; ps-&gt;_size; ++i) &#123; printf(&quot;%d &quot;, ps-&gt;_a[i]); &#125; printf(&quot;\\n&quot;);&#125;void SeqListPushBack(SeqList* ps, SLDateType x) // 尾にデータを削除&#123; assert(ps); SeqListInsert(ps, ps-&gt;_size, x); // 関数再利用&#125;void SeqListPushFront(SeqList* ps, SLDateType x) // ヘッドにデータを挿入&#123; assert(ps); SeqListInsert(ps, 0, x); // 関数再利用 //SeqListCheckCapacity(ps); //if (ps-&gt;_size &gt; 0) //&#123; // int end = ps-&gt;_size - 1; // while (end &gt;= 0) // &#123; // ps-&gt;_a[end + 1] = ps-&gt;_a[end]; // --end; // &#125; //&#125; //ps-&gt;_sizeof++; //ps-&gt;_a[0]=x;&#125;void SeqListPopFront(SeqList* ps) //ヘッドにデータを削除&#123; assert(ps); assert(ps-&gt;_size &gt; 0); SeqListErase(ps, 0); // 関数再利用&#125;void SeqListPopBack(SeqList* ps) // 尾にデータを削除&#123; assert(ps); assert(ps-&gt;_size &gt; 0); ps-&gt;_size--; &#125;// 任意の位置にデータを挿入void SeqListInsert(SeqList* ps, size_t pos, SLDateType x)&#123; assert(ps); assert(pos &gt;= 0 &amp;&amp; pos &lt;= ps-&gt;_size); SeqListCheckCapacity(ps);// 容量サイズを検査 int end = ps-&gt;_size - 1; while (end &gt;= pos &amp;&amp; end &gt;= 0) // 尾+1のところ &#123; ps-&gt;_a[end + 1] = ps-&gt;_a[end]; --end; &#125; ps-&gt;_a[pos] = x; ps-&gt;_size++;&#125;// 任意の位置にデータを削除void SeqListErase(SeqList* ps, size_t pos)&#123; assert(ps); assert(pos &gt;= 0 &amp;&amp; pos &lt; ps-&gt;_size); if (pos == ps-&gt;_size - 1) &#123; ps-&gt;_size--; return; &#125; else &#123; int begin = pos + 1; // pos=0 の場合、範囲外のアクセスを防止する while (begin &lt; ps-&gt;_size) &#123; ps-&gt;_a[begin - 1] = ps-&gt;_a[begin]; begin++; &#125; ps-&gt;_size--; &#125;&#125;// データの検索int SeqListFind(SeqList* ps, SLDateType x)&#123; assert(ps); for (int i = 0; i &lt; ps-&gt;_size; ++i) &#123; if (ps-&gt;_a[i] == x) return i; &#125; return -1;&#125;// データの検索// パラメータ pos を最初に検索する必要があるvoid SeqListModify(SeqList* ps, int pos, SLDateType x) &#123; assert(ps); assert(pos &gt;= 0 &amp;&amp; pos &lt; ps-&gt;_size); ps-&gt;_a[pos] = x;&#125; SeqList.h12345678910111213141516171819202122232425262728293031323334#pragma once#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;stdlib.h&gt;//動的配列の構造typedef int SLDateType;typedef struct SeqList&#123; SLDateType* _a; // 動的配列へのポインター size_t _size; // データサイズ size_t _capacity; // 容量サイズ&#125;SeqList;// 配列の中にデータを追加、削除、検索、変更などvoid SeqListInit(SeqList* ps); // 初期化void SeqListCheckCapacity(SeqList* ps); // 容量サイズを検査void SeqListDestroy(SeqList* ps); // データの破壊void SeqListPrint(SeqList* ps); // 出力関数void SeqListPushBack(SeqList* ps, SLDateType x); // 尾に挿入void SeqListPushFront(SeqList* ps, SLDateType x); // ヘッドにデータを挿入void SeqListPopFront(SeqList* ps); // ヘッドにデータを削除void SeqListPopBack(SeqList* ps); // 尾にデータを削除 // データの検索int SeqListFind(SeqList* ps, SLDateType x);// 任意の位置にデータを挿入void SeqListInsert(SeqList* ps, size_t pos, SLDateType x);// 任意の位置にデータを削除void SeqListErase(SeqList* ps, size_t pos);//改数据void SeqListModify(SeqList* ps, int pos, SLDateType x); // パラメータ pos を最初に検索する必要がある 参考文献 https://github.com/soukenki/Test_for_C/tree/master/SeqList","categories":[{"name":"データ構造とアルゴリズム","slug":"データ構造とアルゴリズム","permalink":"https://soukenki.github.io/categories/%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%E3%81%A8%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/"}],"tags":[{"name":"C言語","slug":"C言語","permalink":"https://soukenki.github.io/tags/C%E8%A8%80%E8%AA%9E/"},{"name":"データ構造とアルゴリズム","slug":"データ構造とアルゴリズム","permalink":"https://soukenki.github.io/tags/%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%E3%81%A8%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/"}]},{"title":"C言語：初めの紹介-1","slug":"C言語：初めの紹介-1","date":"2022-11-29T04:58:51.000Z","updated":"2022-12-09T11:16:51.490Z","comments":true,"path":"2022/11/29/C言語：初めの紹介-1/","link":"","permalink":"https://soukenki.github.io/2022/11/29/C%E8%A8%80%E8%AA%9E%EF%BC%9A%E5%88%9D%E3%82%81%E3%81%AE%E7%B4%B9%E4%BB%8B-1/","excerpt":"本文章については、 Cプログラミング をはじめに学んだ知識のフレームワークです。たとえば、この記事のループでは、while を簡単に紹介するだけです。ここまでが記事の前半で、後でさまざまな文法の詳細に特化した記事を更新して投稿します。興味のある方は、引き続きブログの更新に注目してください〜目次 &gt; 最初のCコード データの種類 便利な関数 printf() の形式 コンピュータの単位 変数と定数 2つの数値の合計を計算する 変数のスコープ 可変寿命 定数 (リテラル定数) (const 修飾された定数変数)・定数（#defineで定義される識別子定数） 定数 (列挙定数) 文字列 文字列の長さを計算する strlen(); エスケープ文字 ‘\\ddd’ 8 進数 ‘\\xdd’ 16 進数 ノート 選択文 ループ文","text":"本文章については、 Cプログラミング をはじめに学んだ知識のフレームワークです。たとえば、この記事のループでは、while を簡単に紹介するだけです。ここまでが記事の前半で、後でさまざまな文法の詳細に特化した記事を更新して投稿します。興味のある方は、引き続きブログの更新に注目してください〜目次 &gt; 最初のCコード データの種類 便利な関数 printf() の形式 コンピュータの単位 変数と定数 2つの数値の合計を計算する 変数のスコープ 可変寿命 定数 (リテラル定数) (const 修飾された定数変数)・定数（#defineで定義される識別子定数） 定数 (列挙定数) 文字列 文字列の長さを計算する strlen(); エスケープ文字 ‘\\ddd’ 8 進数 ‘\\xdd’ 16 進数 ノート 選択文 ループ文 最初のCコード .c ファイルは C 言語のソース ファイルである。 .h ファイルはヘッダー ファイルである。 stdio.h というファイルを含める std-標準 standard標準 input入力 output出力 123456789101112#include&lt;stdio.h&gt;// int は整数を意味し、main の前の int は、main 関数呼び出しの後に整数値が返されることを意味する。int main() // メイン関数 --&gt; プログラム エントリ --&gt; 1 つしかない&#123; /* ここでタスクを実行し、関数を入力する 関数-print function - printf - は画面に出力関数である */ printf(&quot;hello こんにちは。\\n&quot;); return 0; &#125; データの種類 名称 データタイプ サイズ char 文字型 1 short 短整数型 2 int 整数型 4 long 長整数型 4 または 8 long long もっと長整数型 8 float 単精度浮動小数点数 4 double 倍精度浮動小数点数 8 float を使用してデータを初期化する場合、データの後に f を追加すると、コンパイラはデフォルトで double 型になり、f を追加して float にする 文字の初期化: ‘w’ 文字列の初期化: “Name” → 記号の区別に注意 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;int main()&#123; char ch = &#x27;A&#x27;; //char--字符类型 printf(&quot;%c\\n&quot;,ch); // %c--データを文字形式で出力 \\n -- 改行を意味する /* %f--浮動小数点数 (10 進数) を出力する %p--メモリアドレスの形式で出力 %x--16 進数を出力 %o....*/ //short int //短整数型 int age = 20; //整数型 printf(&quot;%d\\n&quot;, age); // %d--整数の 10 進データを出力する //long 長整数型 long nom = 11100; printf(&quot;%d\\n&quot;, nom); float f = 5.2; //単精度浮動小数点数 printf(&quot;%f\\n&quot;, f); double d = 3.14; //倍精度浮動小数点数 printf(&quot;%lf\\n&quot;, d);//倍精度浮動小数点数を出力する場合、%f を使用すると精度が失われる可能性があるため、%lf を使用する方が適切である //sizeof は括弧内のもののサイズを計算するために使用される printf(&quot;%d\\n&quot;, sizeof(char)); //1 printf(&quot;%d\\n&quot;, sizeof(short));//2 printf(&quot;%d\\n&quot;, sizeof(int));//4 printf(&quot;%d\\n&quot;, sizeof(long));// 4/8 C言語標準 sizeof(long) &gt; または = sizeof(int) は問題ない, 4=4 8&gt;4 printf(&quot;%d\\n&quot;, sizeof(long long));//8 printf(&quot;%d\\n&quot;, sizeof(float));//4 printf(&quot;%d\\n&quot;, sizeof(double));//8 return 0;&#125; 便利な関数 printf() の形式 タイプ ロゴ 出力最小幅 精度 長さ12printf(&quot;%02d&quot;, x); //2桁になるように0を埋める 出力：09 printf(&quot;%3d&quot;, x); //スペースを埋めて3桁にする 出力：スペーススペース9 1) タイプ タイプ文字は、出力データのタイプを示すために使用され、その形式と意味を次の表に示します。 %d 符号付き整数を 10 進形式で出力します (正の数は符号を出力しません); 補数コードが %d で出力される場合、元のコードを計算して出力する必要があります printf(“%8d\\n”,100); printf(“%6d\\n”,100); printf(“%-8d\\n”,100); printf(“%+8\\n”,100 ); 出力は次のとおりです。 “+” 右揃え %llu longlong unsigned 型を出力 (64 ビット プラットフォームが %d を出力する場合) %ld 長整数出力 %o 符号なし整数を 8 進数形式で出力します (プレフィックス 0 は出力しません) %x 整数を 16 進数の形式で出力するか、文字列のアドレスを出力します (数値のみを出力します。0x1234 などの形式で出力したい場合は、この形式で出力するには %#x が必要です) %u 符号なし型データ (符号なし数値) を 10 進数で出力します。 注: %d と %u には符号なしの値の範囲、つまり制限値があります。そうしないと、値が正しく出力されません。 %c 文字を出力 %s 文字列を出力 %f 実数を 10 進形式で出力、デフォルトでは小数点以下 6 桁、%.2f を使用すると小数点以下 2 桁を確保 (同様に 1~6) c &#x3D; (float)a &#x2F; b ;&#x2F;&#x2F;ここで強制型変換、フォームの結果を省略せず、小数点以下の数字を表示する %lf 倍精度浮動小数点数の場合、%f を使用すると精度が失われる可能性があるため、%lf %100f 小数点以下 100 桁の実数を出力します。 %e 数値形式で実数を出力 % サイズに応じて f 形式または e 形式を自動的に選択し、無意味なゼロを出力しない %p 印刷アドレス 2) フラグ フラグ文字は、-、+、#、およびスペースであり、その意味は次の表に示されています: - 結果を左揃え、右にスペースを埋める + 出力記号 (プラスまたはマイナス記号) スペース 正の場合は出力値の前にスペースが、負の場合はマイナス記号が先行します。 # クラス c、s、d、u には影響しません; クラス o の場合、出力時にプレフィックス 0 を付けます。 クラス x の場合、出力時にプレフィックス 0x を付けます。 e、g、f クラスの場合、結果に小数点がある場合にのみ小数点が与えられます 3) 出力の最小幅 出力の最小桁数を示すために 10 進整数が使用されます。 実際の桁数が定義幅よりも多い場合は、実際の桁数に応じて出力され、実際の桁数が定義幅よりも小さい場合は、スペースまたは 0 で埋められます。 4) 精度 精度形式指定子は “.” で始まり、その後に 10 進整数が続きます。 この項目の意味: 出力が数値の場合は小数点以下の桁数を示し、出力が文字の場合は出力文字数を示し、実際の桁数が定義された精度の数値よりも大きい場合は、 、余分な部分は切り捨てられます。 5) 長さ 長さの書式指定子は h と l です.h は短整数として出力することを意味し、l は長整数として出力することを意味します. コンピュータの単位 2 バイト — 16 ビット 2^16-1 4 バイト — 32 ビット 2^32-1 ビット — ビット最小、1 ビットは 1 または 0 の 1 つだけを保持できます バイト — バイト 1 バイト &#x3D; 8 ビットのサイズ。 kb — 1024 バイト mb — 1024kb gb—1024mb tb — 1024 GB 正電荷 — 1 負電荷 — 0 バイナリ: (0 と 1 のみ) 10 進法: 0123456789 日常の数字 16 進数: 時間 (1 サイクル 12 時間) 16 進数: 1 週間 (1 サイクル 7 日) 1234567int main()&#123; short age = 20;//メモリに 2 バイトを適用 = 16 ビットで 20 の値を格納 float weight = 95.6f;//メモリに 4 バイトを適用し、10 進数を格納し、値の後に f を追加して 95.6 を指定します。この値は float 型である char ch = &#x27;w&#x27;; return 0;&#125; 変数と定数 定数：学籍番号、ID番号…定数値 変数: 年齢、体重…変数値、C 言語には 2 つの異なるタイプの変数がある (ローカル変数、グローバル変数) 変数1234567891011#include&lt;stdio.h&gt;int num1 = 20;//グローバル変数-コードブロック&#123;&#125;以外の変数を定義します。int num2; //グローバル変数を初期化しないと、デフォルトは0に初期化されます。int main()&#123; int num1 = 10;//ローカル変数 - コード ブロック内で定義された変数 &#123;&#125;; 名前が同じ場合、この行を削除してグローバル変数を直接表示します int a; //ローカル変数が初期化されていない場合、デフォルトでランダムな値になります printf(&quot;%d\\n&quot;, num1);//ローカル変数とグローバル変数の名前はできるだけ同じにしないでください。誤解しやすく、バグの原因となります。 //ローカル変数とグローバル変数が同じ名前の場合、ローカル変数が最初に表示されます。 return 0;&#125; 2つの数値の合計を計算する scanf 関数に関するエラーの報告 プロジェクトの先頭に追加: #define _CRT_SECURE_NO_WARNINGS 1 12345678910111213141516171819#define _CRT_SECURE_NO_WARNINGS 1#include&lt;stdio.h&gt;int main()&#123; int num1 = 0; int num2 = 0; int sum = 0; //C 言語の文法では、変数は現在のコード ブロックの先頭で定義する必要があると規定されています /* 入力データ - 入力関数 scanf を使用 vs2019 に (_s) を追加 scanf_s() の機能は scanf() と同じですが、scanf() よりも安全です。 scanf_s() は、「scanf() が文字列を読み取るときに境界をチェックしないため、メモリ リークが発生する可能性がある」という問題のために設計されているためです。 scanf_s() を使用して文字列を読み取る場合、オーバーフローを防ぐために読み取る最大文字数を示す数値を指定する必要があります。 [scanf_s()] これはvsにしか使えない、他のソフトは非対応、クロスプラットフォームがないので使わないようにして、 コンパイラがエラーを報告しないように、ソース ファイルの先頭に #define _CRT_SECURE_NO_WARNINGS 1 を追加します*/ scanf(&quot;%d%d&quot;,&amp;num1,&amp;num2);//アドレス シンボル &amp; scanf によって入力された値が大きすぎる場合でも、メモリに強制的に格納され、オーバーフローが発生します。 sum = num1 + num2; //scanf は、ターゲット スペースが収まるかどうかは気にしません。 printf(&quot;sum=%d\\n&quot;, sum);//%d の前の (sum=) がデバッグに表示されます return 0;&#125; while(scanf(“%d”,&amp;a) &#x3D;&#x3D; 1) &#x2F;&#x2F;scanf が入力情報を正常に読み取った場合、戻り値は 1; 入力情報を読み取ることができなかった場合、戻り値は EOF EOF 値は -1 while(scanf(“%d”,&amp;a) !&#x3D; EOF) プログラムを終了するには、ctrl + z を押します 変数のスコープ1234567891011121314151617181920#include&lt;stdio.h&gt;int global = 2020;// グローバル変数のスコープはプロジェクト全体void test()&#123; printf(&quot;test()--%d\\n&quot;, global);// ここでは実行せず、宣言するだけです&#125;int main()&#123; &#123; int num = 0; // ローカル変数のスコープは、ローカル変数が &#123;&#125; でのみ機能することです printf(&quot;num=%d\\n&quot;, num);// printf(&quot;num=%d\\n&quot;, num); を変数 int num = 0; の &#123;&#125; の外に移動すると動作しません &#125; printf(&quot;global=%d\\n&quot;, global); test();//mainでvoid関数が呼ばれるので実行される //同じプロジェクトで、異なるソース ファイルにグローバル変数 int g_val = 2021 があります。 //extern外部シンボル(他のソースファイルのグローバル変数)の宣言 extern int g_val; printf(&quot;g_val=%d\\n&quot;, g_val); //このときg_val=2021と表示されます return 0;&#125; 変数のライフサイクルローカル変数のライフサイクルは {} にありますが、グローバル変数のライフサイクルはプログラム全体のライフサイクルです 12345678910#include&lt;stdio.h&gt;int main()&#123; &#123;// ライフサイクルの開始 int a = 10; printf(&quot;a=%d\\n&quot;, a);//ok &#125;// ライフサイクルの終わり printf(&quot;a=%d\\n&quot;, a);//エラー return 0;&#125; 定数 (リテラル定数) (const 修飾された定数変数)const - 定数プロパティ 123456789101112131415#include&lt;stdio.h&gt;int main()&#123; //const-constant プロパティ、 //const int n = 10;//n は変数ですが、定数属性を持っているため、n は定数変数であると言えます //int arr[10] = &#123; 0 &#125;;//配列 [] は定数値を使用して実行する必要があり、定数変数に置き換えることはできません const int num = 4;//int num は num を 4 として定義します。これは変数に属し、前に const が追加され、const によって変更された定数変数になります。 printf(&quot;%d\\n&quot;,num); num = 8;//前の int num=4 は変数であり、実行できます。 ただし、const を追加して定数変数にする場合、num=8 はエラーになります。 printf(&quot;%d\\n&quot;, num); 3;// リテラル定数 3.14;// リテラル定数 return 0;&#125; 定数（#defineで定義される識別子定数）123456789#include&lt;stdio.h&gt; //#define 定義済み識別子定数 (マクロ定義を定義)#define MAX 10 // MAX という定数シンボルを定義し、次の 10 は 10 として定義されていることを意味しますint main()&#123; int arr[MAX] = &#123;0&#125;;// definer で定義した定数を配列[]で使用可能 printf(&quot;%d\\n&quot;, MAX); // 出力：10 return 0;&#125; 定数 (列挙定数)（例1：）12345678910111213141516171819// 列挙定数// 列挙 - 1 つずつリストします (性別: 男性、女性、内密。三原色: 赤、黄、青。)// 列挙キーワード - enumenum Sex //性別: 男性、女性、内密。&#123; MALE, FEMALE, SECRET&#125;; //MALE,FEMALE,SECRETこれらの 3 つの値 - 列挙定数#include&lt;stdio.h&gt;int main()&#123; //enum Sex s = MALE;//sという人は男性です enum Sex s = MALE;//列挙値は設定値のみを取ることができます: MALE、FEMALE、SECRET のいずれか 1 つだけ printf(&quot;%d\\n&quot;, MALE);//列挙定数には値があり、デフォルトの順序は 0、1、2... で、変更できません printf(&quot;%d\\n&quot;, FEMALE); printf(&quot;%d\\n&quot;, SECRET); return 0;&#125; （例2：）12345678910111213enum Color //三原色: 赤、黄、青。&#123; RED, YELLOW, BLUE&#125;;int main()&#123; enum Color color = BLUE;// color という名前の色は青 BLUE color = YELLOW;//この色は単なるアイテムの名前であり、変数であり、変更できます //BLUE = 6;//これは列挙型で定義された定数で、デフォルトでは 0, 1, 2 でなければなりません... 色自体は変更できないため、エラー return 0;&#125; 文字列文字列 — “”で囲まれた文字‘\\0’ — エスケープ文字 — 0 1234567891011121314151617#include&lt;stdio.h&gt; // 0-数字0int main() // &#x27;0&#x27; --&gt; 文字 0、ASCII 値: 48&#123; char arr1[] = &quot;abc&quot;;//配列 // &quot;abc&quot; は &#x27;a&#x27;&#x27;b&#x27;&#x27;c&#x27;&#x27;\\0&#x27;------&#x27;\\0&#x27; 文字列終了マークと同等です char arr2[] = &#123; &#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;\\0&#x27;&#125;; // &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125; には &#x27;a&#x27;&#x27;b&#x27;&#x27;c&#x27; のみがあり、終了記号はありません。 そのため、&#123;&#125; を使用して文字列を入力する場合は、文字の終わりを意味する &#x27;\\0&#x27; または 0 を追加する必要があります。 printf(&quot;%s\\n&quot;, arr1);// %s で文字列を出力 printf(&quot;%s\\n&quot;, arr2);// \\0 が見つからない場合は、逆方向に読み取り続け、エラーが発生します。 &quot;hello bit&quot;; &quot;&quot;;// 空の文字列 return 0; // データがコンピュータに保存されるときは、バイナリで保存されます // 各文字には対応する値があります #aA$hud... 例: a-97 A-65 \\0-0 ... // ASCII エンコード、各文字には ASCII コードがあります // ASCII コード値、各 ASCII コードに対応する値&#125; 文字列の長さを計算する strlen();12345678910#include&lt;stdio.h&gt;#include&lt;string.h&gt; //strlen関数のヘッダファイル（長さ計算用ヘッダファイル）int main()&#123; char arr1[] = &quot;abc&quot;;//長さ：3 char arr2[] = &#123; &#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;//長さ：\\0 がない場合、結果はランダムな値になります。&#x27;\\0&#x27; を追加すると、長さは 3 になります。 printf(&quot;%d\\n&quot;, strlen(arr1));//strlen - string length - 文字列の長さを計算するために使用されます printf(&quot;%d\\n&quot;, strlen(arr2)); return 0;&#125; ここの \\0 はエスケープ文字です。つまり、文字の前に「\\」を追加して、文字の本来の意味を変更します。 例: ‘\\n’ - リテラルの ‘n’ から ‘改行’ の意味へ、 ‘\\t’ –&gt; ‘水平タブ’, ‘\\r’ –&gt; ‘Enter’ ….. (詳しくは下記のエスケープ文字ルール表をご覧ください) エスケープ文字 エスケープ文字 意味 ASCII コード値 (10 進数) \\a ベル (BEL)、警告文字 007 \\b バックスペース (BS)、現在位置を前の列に移動 008 \\f フォーム フィード (FF)、現在の位置を次のページの先頭に移動 012 \\n 改行 (LF)、現在位置を次の行の先頭に移動 010 \\r キャリッジ リターン (CR)、現在位置を行頭に移動 013 \\t 水平タブ (HT) (次のタブ位置にジャンプ) 009 \\v 垂直タブ (VT) 011 \\\\ はバックスラッシュ文字 ‘ \\‘ を表します 092 \\‘ は一重引用符 (アポストロフィ) 文字を表します 039 \\“ は二重引用符を表します 034 \\? 疑問符を表すため、3 文字の単語として認識されません (are you ok??)&#x3D;&gt;(are you ok] ??) &#x3D;&gt; ] 063 \\0 ヌル文字 (NUL) 000 \\ddd ddd は 1~3 の 8 進数 3 桁の 8 進数 \\xdd dd は 2 桁の 16 進数を意味します 16 進数 例：123456789#include&lt;stdio.h&gt;int main()&#123; printf(&quot;c:\\\\2013\\\\music\\\\zhou.mp3&quot;);//システムが「\\」をエスケープ文字として解釈しないようにするには、「\\」を「\\\\」と記述します。 //このとき得られる結果は c:\\2013\\music\\zhou.mp3 のようなアドレスです printf(&quot;%c\\n&quot;, &#x27;\\&#x27;&#x27;);//同様に、&#x27;--&gt;\\&#x27; を使用して記号を表示できます&#x27; printf(&quot;%s\\n&quot;, &quot;\\&quot;&quot;);//文字列も同様です return 0;&#125; ‘\\ddd’ 8 進数1234567891011121314#include&lt;stdio.h&gt;#include&lt;string.h&gt; //長さを計算するためのヘッダー ファイルint main()&#123; printf(&quot;%d\\n&quot;, strlen(&quot;c:\\test\\32\\test.c&quot;));//長さは 13 ですが、なぜ 13 なのですか? \\t は 1 文字として数えます printf(&quot;%c\\n&quot;, &#x27;\\32&#x27;);//「→」を表示 // \\32 -- 32 は 2 つの 8 進数 (8、9 およびその他の 7 を超える値は表示できません) 3*8^1+2*8^0 = 24+2 =26 26 は ASCII コード &#x27;→&#x27; // 8 進数として 32 --&gt; 10 進数、10 進数 --&gt; ASCII コード値に対応する文字 // 32--&gt;10 進数 26-&gt;ASCII コード値で表される文字として printf(&quot;%c\\n&quot;, &#x27;\\132&#x27;);//&#x27;Z&#x27;を表示 // 8 進数：\\132 -- 1*8^2+3*8^1+2*8^0 = 64+24+2 = 90 --&gt; ASCIIコード値は：&#x27;Z&#x27; //したがって、\\32 は文字 &#x27;→&#x27; です。 return 0;&#125; ‘\\xdd’ 16 進数123456#include&lt;stdio.h&gt;int main() //&#x27;\\&#x27; の後ろの数字は数字のみ: 8 進数; &#x27;\\x&#x27; と数字の場合: 16 進数。&#123; printf(&quot;%c\\n&quot;, &#x27;\\x61&#x27;);//16 進数アルゴリズム：\\x61 -- 6*16^1+1*16^0 = 96+1= 97 --&gt; ASCIIコード値は：&#x27;a&#x27; return 0;//16 進数を 10 進数に変更し、対応する ASCII コード値に対応させます。&#125; ノート C言語スタイル: &#x2F;*xxxxxxxx*&#x2F; 短所: ネスト (&#x2F;*xxxx&#x2F;*xx*&#x2F;xxxx*&#x2F;) をサポートしていません。後半部分はノートされていません。 C++ スタイル: &#x2F;&#x2F;xxxxxxxxxxx 1 行または複数行のノートを付けることができます (推奨) 選択文123456789101112131415#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; int input = 0; printf(&quot;大学にいる\\n&quot;); printf(&quot;君は努力してるの？入力してください(1,0)&gt;:&quot;); scanf(&quot;%d&quot;, &amp;input); //入力機能、選択入力 1/0 if (1 == input) //if-場合 1 つの「=」は代入を意味し、2 つの「=」はそれらが等しいかどうかを判断することを意味します。 printf(&quot;良いoffer\\n&quot;); //else //else-他の if (0 == input) //こいうふうにも使えます printf(&quot;無職\\n&quot;); return 0;&#125; ループ文 while演算子 for演算子 do…while演算子 while例：123456789101112131415#include&lt;stdio.h&gt;int main()&#123; printf(&quot;大学にいる\\n&quot;); int line = 0; while (line &lt; 20000) &#123; printf(&quot;プログラミングをする量:%d\\n&quot;,line); line++; //変数の値を 1 増やします。同様に、「--」は値を 1 減らします &#125; if (line &gt;= 20000) //&gt;または= 20000までループし続ける printf(&quot;良いoffer\\n&quot;); return 0;&#125; (この文章はまだ終わっていません。引き続き「 C言語：初めの紹介-２」を参照してください) 参考文献 https://github.com/soukenki","categories":[{"name":"C言語","slug":"C言語","permalink":"https://soukenki.github.io/categories/C%E8%A8%80%E8%AA%9E/"}],"tags":[{"name":"C文法","slug":"C文法","permalink":"https://soukenki.github.io/tags/C%E6%96%87%E6%B3%95/"}]},{"title":"はじめまして","slug":"はじめまして","date":"2022-11-22T16:11:59.000Z","updated":"2022-11-23T09:07:11.891Z","comments":true,"path":"2022/11/23/はじめまして/","link":"","permalink":"https://soukenki.github.io/2022/11/23/%E3%81%AF%E3%81%98%E3%82%81%E3%81%BE%E3%81%97%E3%81%A6/","excerpt":"目次 自己紹介 目標 興味など ソースコード庫","text":"目次 自己紹介 目標 興味など ソースコード庫 自己紹介こんにちは。ソウ ケンキと申します。このブログは、自分としてIT技術の理解や活用など情報をまとめるモノです。 今日本の大学で情報について、様々な知識を勉強しています。主に、C&#x2F;C++・Linuxなどの学習をやっています。 私の性格は楽観的で明るいです。趣味は旅行、グルメ、音楽、釣りなどです。若し、皆さんは私のブログに対して、何かアドバイスや質問があれば、ぜひメール・LineやWeChatで連絡してください。 目標一生懸命に勉強して、様々な知識を身につけるようになります。将来的には社会に役立つ、人々の生活を変えながら、生活をより便利にする製品を開発することができるように目指しています。 掲示板最後に、自分の興味として旅行や美食などの写真シェアを掲示します。 瑞龍寺 高岡大佛 和牛ステーキ ソースコード庫 https://github.com/soukenki","categories":[],"tags":[]}],"categories":[{"name":"データ構造とアルゴリズム","slug":"データ構造とアルゴリズム","permalink":"https://soukenki.github.io/categories/%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%E3%81%A8%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/"},{"name":"C言語","slug":"C言語","permalink":"https://soukenki.github.io/categories/C%E8%A8%80%E8%AA%9E/"}],"tags":[{"name":"C言語","slug":"C言語","permalink":"https://soukenki.github.io/tags/C%E8%A8%80%E8%AA%9E/"},{"name":"データ構造とアルゴリズム","slug":"データ構造とアルゴリズム","permalink":"https://soukenki.github.io/tags/%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%E3%81%A8%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/"},{"name":"C文法","slug":"C文法","permalink":"https://soukenki.github.io/tags/C%E6%96%87%E6%B3%95/"}]}