{"meta":{"title":"Skk分享屋","subtitle":"","description":"本博客是作者对计算机相关专业知识的理解，以及其运用时作出的学习和总结。","author":"Skk","url":"https://soukenki.github.io/zh-CN","root":"/zh-CN/"},"pages":[{"title":"关于作者","date":"2022-11-22T10:39:30.000Z","updated":"2022-11-25T17:05:01.681Z","comments":true,"path":"about/index.html","permalink":"https://soukenki.github.io/zh-CN/about/index.html","excerpt":"","text":"你好。我叫 Skk。我现在是大学三年级的学生。我正在学习 C&#x2F;C++、Linux 等。 本博客是作者对计算机相关专业知识的理解，以及其运用时作出的学习和总结。 邮箱：&#x61;&#x31;&#x31;&#x30;&#x36;&#54;&#x37;&#49;&#53;&#x32;&#x38;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;如果您有任何建议或问题，请通过电子邮件、Line 或微信与我联系。 非常感谢您对本站的支持。之后会持续更新~ （关于搜索功能的温馨提示：搜索先定位文章，具体文字位置请利用 Ctrl + f 的浏览器功能）"},{"title":"主页","date":"2022-11-18T16:54:27.000Z","updated":"2022-11-22T13:22:55.226Z","comments":true,"path":"categories/index.html","permalink":"https://soukenki.github.io/zh-CN/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-11-18T16:57:58.000Z","updated":"2022-11-22T13:22:56.109Z","comments":true,"path":"tags/index.html","permalink":"https://soukenki.github.io/zh-CN/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C语言：函数详解","slug":"C语言：函数详解","date":"2022-11-26T16:57:17.000Z","updated":"2022-11-29T04:44:38.381Z","comments":true,"path":"2022/11/27/C语言：函数详解/","link":"","permalink":"https://soukenki.github.io/zh-CN/2022/11/27/C%E8%AF%AD%E8%A8%80%EF%BC%9A%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/","excerpt":"关于本文章，介绍C语言中的各种函数语法和函数使用的技巧等，希望能帮助大家更好地了解函数。目录 &gt; 函数 库函数 自定义函数 函数参数 传值调用和传址调用 传值调用 传址调用 嵌套调用 链式访问 函数的声明和定义 声明 定义 函数外部分工 函数的递归 递归求字符串的长度 迭代与递归的区别","text":"关于本文章，介绍C语言中的各种函数语法和函数使用的技巧等，希望能帮助大家更好地了解函数。目录 &gt; 函数 库函数 自定义函数 函数参数 传值调用和传址调用 传值调用 传址调用 嵌套调用 链式访问 函数的声明和定义 声明 定义 函数外部分工 函数的递归 递归求字符串的长度 迭代与递归的区别 函数函数一般是由一个或者多个代码块组成，主要是以完成某项特定的任务为目的，比如排序函数，其目的就是排序。而且函数与函数之间具有相对独立性。 函数具体分为： 库函数 自定义函数 库函数为什么会有库函数呢？？ 我在学习C语言的时候，经常会用到很多特定的函数，比如printf打印，这是我们大部分初学者第一次都会接触到的函数。但是，大家有没有想过，为什么会有这个函数的存在？它为什么可以神奇地显示字符到屏幕上呢? 其实，它是一个库函数。因为在开发过程中，开发者经常要使用一些功能大致相同的函数。如果每次都重新写一个函数，那么太浪费时间了。 所以，衍生出了库函数：把大家经常会用到的函数打包到一个库里面，要用的时候去库里面取就好了。如果实在是有其他特别要求的话，再重新写。这样大大节省了开发者的开发时间，提高了开发效率。 如何学习库函数？ 这里我推荐一个查看库函数的网站：https://cplusplus.com/ 简单的总结，C语言常用的库函数都有： IO函数 字符串操作函数 字符操作函数 内存操作函数 时间&#x2F;日期函数 数学函数 其他库函数 我们可以在库函数的网站里，通过头文件进行对函数的查找。 如何计算n的k次方这样的运算，可以通过数学头文件进行查找。 然后在头文件包含的函数找到需要的函数。 函数是由函数名、参数、返回值，三个部分组成。 库函数包含的函数量是非常巨大的，我们只能通过查找进行使用，要全部记下来是非常困难的事情。 自定义函数如果库函数能干所有的事情，那还要程序员干什么？比起库函数，自定义函数才是最重要的。自定义函数也是和库函数一样，由函数名、参数、返回值，三个部分组成。但是自定义函数的自由度更高，可以根据不同的需求，设计不同的函数，让程序员可以有很大的发挥空间。 自定义函数例： 写一个函数可以找出两个整数中的最大值。123456789101112int get_max(int x, int y)&#123; return (x &gt; y) ? (x) : (y);&#125;int main()&#123; int num1 = 10; int num2 = 20; int max = get_max(num1, num2); printf(&quot;max = %d\\n&quot;, max); return 0;&#125; 函数参数 实际参数（实参）：真实传给函数的参数，叫实参。实参可以是：常量、变量、表达式、函数等。无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参。 形式参数（形参）：形式参数是指函数名后括号中的变量，因为形式参数只有在函数被调用的过程中才实例化（分配内存单元），所以叫形式参数。形式参数当函数调用完成之后就自动销毁了。因此形式参数只在函数中有效。 上面这两个自定义函数Add1和Add2，分别调用之后，参数会发生什么样的变化呢？ 代码对应的内存分配如下： 所以我们可以简单的认为：形参实例化之后其实相当于实参的一份临时拷贝。 写一个函数,实现整型有序数组的二分查找: 通过自定义函数，把二分查找从main函数中分离出来12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;int binary_search(int arr[], int k,int sz)&#123; //算法实现 int left = 0; int right = sz - 1; while (left&lt;=right) &#123; int mid = (left + right) / 2; //中间元素下标 if (arr[mid] &lt; k) &#123; left = mid + 1; &#125; else if (arr[mid] &gt; k) &#123; right = mid - 1; &#125; else &#123; return mid; &#125; &#125; return -1;&#125;int main()&#123; //二分查找:在一个有序数组中查找具体的某个数 //如果找到了返回,这个数的下标,找不到的返回-1 int arr[] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;; int k = 7; int sz = sizeof(arr) / sizeof(arr[0]); //计算元素个数 // 传递过去的是数组arr首元素的地址 int ret = binary_search(arr,k,sz); if (ret == -1) &#123; printf(&quot;找不到指定的数字\\n&quot;); &#125; else &#123; printf(&quot;找到了,下标是:%d\\n&quot;,ret); &#125; return 0;&#125; 当自定义函数把 数组 传进函数体中时，传的是首元素的地址，也就是指针。 传值调用和传址调用 Add1函数用的是 传值调用。 Add2函数用的是 传址调用。 传值调用 函数的形参和实参分别占有不同内存块，对形参的修改不会影响实参。 传址调用 传址调用是把函数外部创建变量的内存地址传递给函数参数的一种调用函数的方式。 这种传参方式可以让函数和函数外边的变量建立起真正的联系，也就是函数内部可以直接操作函数外部的变量。 练习：写一个函数，每调用一次这个函数，就会将num 的值增加 1。 12345678910111213141516#include &lt;stdio.h&gt;void AddNum(int* n)&#123; *n += 1;&#125;int main()&#123; int num = 0; while (num &lt; 100) &#123; //调用函数，使得num每次增加1 AddNum(&amp;num); printf(&quot;%d &quot;, num); &#125; return 0;&#125; 输出结果： 嵌套调用函数可以嵌套调用，但是不能嵌套定义。 123456789101112131415161718#include&lt;stdio.h&gt;void new_line()&#123; printf(&quot;hehe\\n&quot;);&#125;void three_line() //把前面那个自定义函数放入新的自定义函数中,形成新的函数&#123; int j = 0; for (j = 0; j &lt; 3; j++) &#123; new_line(); //函数可以嵌套调用,但不能嵌套定义。 &#125;&#125;int main()&#123; three_line(); return 0;&#125; 链式访问把一个函数的返回值作为另外一个函数的参数。例1: 1234567891011#include&lt;stdio.h&gt; int main()&#123; int len = 0; //1 len = strlen(&quot;abc&quot;); printf(&quot;%d\\n&quot;, len); //结果为3 //2 printf(&quot;%d\\n&quot;, strlen(&quot;abc&quot;)); //结果也是为3 return 0;&#125; 例2: 123456#include&lt;stdio.h&gt;int main()&#123; printf(&quot;%d&quot;, printf(&quot;%d&quot;,printf(&quot;%d&quot;,43))); return 0;&#125; 结果是43 2 1 先打印43，然后打印43的返回值，printf()的返回值是它打印的值的个数–&gt;2 ，如此类推最后打印 1 。 函数的声明和定义例1： 定义在main函数后面时,要在main函数前面加上: 函数的声明123456789101112131415161718#include&lt;stdio.h&gt;int Add(int, int); //句尾加;int main()&#123; int a = 10; int b = 20; int sum = 0; //函数调用 sum = Add(a, b); printf(&quot;%d\\n&quot;, sum); return 0;&#125;//下面属于：函数的定义int Add(int x,int y)&#123; int z = x + y; return z;&#125; 如果把函数写在main函数前面，这里就可以不用写声明。 例2：函数定义和声明的一般正常用法 : 先分别创建一个add.c和一个add.h的源文件。 把 函数的定义 放入add.c的源文件中。 add.c1234int Add(int x,int y)&#123; return x + y;&#125; 再把 函数的声明 放入add.h的源文件中。 add.h12345#ifndef __ADD_H__ //判断int main()源文件中是否已经引用过同一个头文件；如果有,则跳到结束#define __ADD_H__ //如果没有,这里进入引用//函数的声明int Add(int, int); //声明的引用，句尾加;号#endif //引用结束 这样做可以避免重复引用头文件而导致的:头文件代码不断拷贝到int main()中;使源文件更简洁 这样就可以在int main()中使用这个自定义函数了。 main.c1234567891011#include&lt;stdio.h&gt; //引用库函数头文件用&lt;&gt;符号#include&quot;add.h&quot; //引用自定义函数头文件用&quot;&quot;符号int main()&#123; int a = 10; int b = 20; int sum = 0; sum = Add(a, b); //这里就变可以使用了 printf(&quot;%d\\n&quot;, sum); return 0;&#125; 声明 告诉编译器有一个函数叫什么，参数是什么，返回类型是什么。但是具体是不是存在，函数声明决定不了。 函数的声明一般出现在函数的使用之前。要满足先声明后使用。 函数的声明一般要放在头文件中的。 定义 函数的定义是指函数的具体实现，交待函数的功能实现。 函数外部分工隐藏代码的实现信息: 写函数代码.c，创建.h头文件，在头文件中对函数进行声明 隐藏.c代码 解决方案管理器 - 项目名 - 右键属性 常规 - 配置类型 - 静态库.lib 生成 - 生成解决方案 在Debug文件夹中，生成.lib文件 把.h头文件 和 .lib静态库文件 一起复制到主函数文件夹中 主函数 - 解决方案管理器 - 导入现有文件 静态库使用方法： #include “XXXX.h” &#x2F;&#x2F;包含头文件 #pragma comment( lib, “XXXX.lib” ) &#x2F;&#x2F;导入静态库 函数的递归特点: 函数自己调用自身 把大型问题转化为与原问题相似的小问题 少量的代码完成多次的计算总结: 把大事化小 1234567#include&lt;stdio.h&gt;int main()&#123; printf(&quot;hehe\\n&quot;); main(); //main()中再使用main()本身(递归),导致死循环打印hehe return 0;&#125; 虽然是死循环,但是它还是会停下来,并提示Stack overflow –&gt;递归常见的错误:栈溢出 stack overflow（因为变量是在内存的栈区申请空间，死循环导致栈区空间被耗光了，迫使程序停下来，这就是栈溢出） 内存中分为: 栈区: 局部变量、函数形参 堆区: 动态开辟的内存（malloc、calloc） 静态区: 全局变量、static修饰的变量(之后会更新新的文章进行详细介绍，留意更新~) 练习：接受一个整型值（无符号），按顺序打印它的每一位。例如：输入：123 输出 1 2 3 1234567891011121314151617#include&lt;stdio.h&gt;void print(int n) &#123; if (n &gt; 9) &#123; print(n / 10); &#125; printf(&quot;%d &quot;, n % 10);&#125;int main()&#123; unsigned int num = 0; scanf(&quot;%d&quot;, &amp;num); //递归 print(num); return 0;&#125; 以输入:123 为例： 第一次123&gt;9进去,123&#x2F;10&#x3D;12,第二次12&gt;9再进去,12&#x2F;10&#x3D;1,第三次进去1!&gt;9,跳出递归 第三次时n&#x3D;1跳出,1%10&#x3D;1,打印1,返回上一层12%10&#x3D;2,打印2,再返回上一层123%10&#x3D;3,打印3 所以得出的结果为1 2 3 递归的两个必要条件： 存在限制条件，当满足这个限制条件时，递归便不再继续。 每次递归调用之后，越来越接近这个限制条件。 递归求字符串的长度把大事化小 思路:my_strlen2(“Skk”);1 + my_strlen(“kk”);1 + 1 + my_strlen(“k”);1 + 1 + 1 + my_strlen(“”);1 + 1 + 1 + 0 &#x3D; 3 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;string.h&gt;int my_strlen1(char* str) //非递归//可以实现求字符串长度,但创建了临时变量,不是递归&#123; int count = 0; while (*str != &#x27;\\0&#x27;) //因为从首元素开始,S不是\\0,就记录一次,Skk共3次,count从0加到了3,再返回count的值 &#123; count++; str++; //str++每+一次,往后走一个单位 S -&gt; k -&gt; k -&gt; \\0 &#125; return count;&#125;int my_strlen2(char* str) //递归的方法&#123; if (*str != &#x27;\\0&#x27;) return 1 + my_strlen(str + 1);//这里不能写++,要写+1//最后一次返回1+0,第二次返回1+1,第三次返回1+2 else return 0;&#125;int main()&#123; char arr[] = &quot;Skk&quot;; //int len = strlen(arr); //求字符串长度的 库函数 //printf(&quot;%d\\n&quot;, len); //模拟实现一个求字符串长度的 自定义函数 int len = my_strlen2(arr); //arr是数组,数组传参,传过去的不是整个数组,而是第一个元素的地址 printf(&quot;len=%d\\n&quot;, len); return 0;&#125; 迭代与递归的区别 迭代：循环是一种迭代。 例1：求n的阶乘。（不考虑溢出） 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;int Fac1(int n)//循环的方式&#123; int i = 0; int ret = 1; for (i = 1; i &lt;= n; i++) &#123; ret *= i; &#125; return ret;&#125;int Fac2(int n)//递归的方式&#123; if (n &lt;= 1) return 1; //例如5，5&gt;1,进去5*Fac2,进去5-1=4，4&gt;1,再进去4*Fac2，如此类推5-4-3-2-1， else return n * Fac2(n - 1); //当1=1返回1，跳出递归，不断返回值,使1*2*3*4*5，最好返回计算结果&#125;int main()&#123; //求n的阶乘 int n = 0; int ret1 = 0; int ret2 = 0; scanf(&quot;%d&quot;, &amp;n); ret1 = Fac1(n);//循环的方式 printf(&quot;%d\\n&quot;, ret1); ret2 = Fac2(n);//递归的方式 printf(&quot;%d\\n&quot;, ret2); return 0;&#125; 例2：求第n个斐波那契数。斐波那契数列：1 1 2 3 5 8 13 21 34 55… 前面两个数之和等于第三个数。 1234567891011121314151617181920212223242526272829303132333435363738int count = 0;int Fid1(int n) // 递归 （不推荐）&#123; if (n == 3)//测试第三个斐波那契数的计算次数 &#123; count++; &#125; if (n &lt;= 2) return 1; else return Fid(n - 1) + Fid(n - 2);//这时用递归就不是便利的方法了 &#125;int Fid2(int n) // 非递归&#123; int a = 1; int b = 1; int c = 1; while (n &gt; 2) &#123; c = a + b;//保存结果的变量 a = b; b = c; n--; &#125; return c;&#125;#include&lt;stdio.h&gt;int main()&#123; int n = 0; int ret = 0; scanf(&quot;%d&quot;, &amp;n); //TDD--测试驱动开发 ret = Fid2(n); printf(&quot;ret = %d\\n&quot;, ret); //printf(&quot;count=%d\\n&quot;, count); return 0;&#125; 同样的例子，做法不同，也就有了不同的定义迭代法也称辗转法，是一种不断用变量的旧值递推新值的过程，跟迭代法相对应的是直接法(或者称为一次解法)，即一次性解决问题。 迭代和递归的关系和区别： 从概念上讲，递归就是指程序调用自身的编程思想，即一个函数调用本身；迭代是利用已知的变量值，根据递推公式不断演进得到变量新值得编程思想。简单地说，递归是重复调用函数自身实现循环。迭代是函数内某段代码实现循环，而迭代与普通循环的区别是：循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。 迭代与普通循环的区别是：迭代时，循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。 递归与普通循环的区别是：循环是有去无回，而递归则是有去有回(因为存在终止条件)。在循环的次数较大的时候，迭代的效率明显高于递归。 应该什么时候用递归？什么时候用循环？两种都可以用，选简单的方式写。但是要注意不能有问题，例如栈溢出，效率慢，这时就不要用递归了。 有些满足两个必要条件的递归，也会发生问题（栈溢出）例如： 123456789101112void test(int n) // 栈溢出&#123; if (n &lt; 10000) &#123; test(n + 1); &#125;&#125;int main()&#123; test(1); // err return 0;&#125; 本章节完，感谢阅览！下一篇文章打算介绍一些经典的递归题，感兴趣的话请持续关注我的更新~ 参考文献 https://github.com/soukenki C库函数样例图出自：https://cplusplus.com/","categories":[{"name":"C语言","slug":"C语言","permalink":"https://soukenki.github.io/zh-CN/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语法","slug":"C语法","permalink":"https://soukenki.github.io/zh-CN/tags/C%E8%AF%AD%E6%B3%95/"}]},{"title":"C语言-分支和循环-下","slug":"C语言-分支和循环-下","date":"2022-11-24T15:22:27.000Z","updated":"2022-11-25T17:53:05.084Z","comments":true,"path":"2022/11/25/C语言-分支和循环-下/","link":"","permalink":"https://soukenki.github.io/zh-CN/2022/11/25/C%E8%AF%AD%E8%A8%80-%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF-%E4%B8%8B/","excerpt":"关于本文章，介绍了C语言中的关于分支语句和循环语句的例题练习题的题解哦~目录 &gt; 练习题 比较两个字符串是否相等 求最大公约数 打印1000~2000之间的闰年 打印100~200之间的素数 找最大值 打印9*9乘法口诀表 水仙花数 变种水仙花数 打印菱形 喝汽水 杨辉三角 猜凶手 比赛预测 其他 关机小程序","text":"关于本文章，介绍了C语言中的关于分支语句和循环语句的例题练习题的题解哦~目录 &gt; 练习题 比较两个字符串是否相等 求最大公约数 打印1000~2000之间的闰年 打印100~200之间的素数 找最大值 打印9*9乘法口诀表 水仙花数 变种水仙花数 打印菱形 喝汽水 杨辉三角 猜凶手 比赛预测 其他 关机小程序 练习题练习 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;windows.h&gt; //Sleep 停止函数的头文件#include&lt;stdlib.h&gt; //system 执行系统命令函数的头文件int main()&#123; char arr1[] = &quot;welcome to beijin!!!!!&quot;; char arr2[] = &quot;###################&quot;; int left = 0; //int right = sizeof(arr1) / sizeof(arr1[0]) - 2;//这里-1是errer，因为还有个隐藏的\\n,所以要-2 int right = strlen(arr1) - 1; //函数strlen计算数组长度,-1是因为隐藏的\\n while (left &lt;= right) &#123; arr2[left] = arr1[left]; arr2[right] = arr1[right]; printf(&quot;%s\\n&quot;, arr2); //打印一次休息一秒 Sleep(1000); //停止,时间单位是毫秒 system(&quot;cls&quot;); //执行系统命令的一个函数- cls -清空屏幕 left++; right--; if (left &gt; right) //这句和break;在这里可以省略 break; // &#125; printf(&quot;%s\\n&quot;, arr2); return 0;&#125; 比较两个字符串是否相等123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;string.h&gt; //库函数strcmp:比较两个字符串是否相等;当两个字符串相等时,返回一个0,所以用==0来判断int main()&#123; int i = 0; char password[20] = &#123; 0 &#125;; for (i = 0; i &lt; 3; i++) &#123; printf(&quot;请输入密码:&gt;&quot;); scanf(&quot;%s&quot;, password); if (strcmp(password,&quot;123456&quot;)==0) // == 不能用来比较两个字符串是否相等,应该使用一个库函数- strcmp &#123; printf(&quot;登录成功!\\n&quot;); break; &#125; else &#123; printf(&quot;密码错误,登录失败\\n&quot;); &#125; &#125; if (i == 3) printf(&quot;三次密码均错误,退出程序\\n&quot;); return 0;&#125; 求最大公约数12345678910111213141516#include&lt;stdio.h&gt;int main()&#123; //求最大公约数 int m = 24; int n = 18; int r = 0; scanf(&quot;%d%d&quot;, &amp;m, &amp;n); while (r = m%n) &#123; //r = m % n; m = n; n = r; &#125; printf(&quot;%d\\n&quot;, n); return 0;&#125; 最小公倍数： 如果 a 和 b 的最大公约数是 m 那么， 最小公倍数为： a * b &#x2F; m ; 打印1000~2000之间的闰年1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;int main()&#123; int year = 0; int count = 0; for (year = 1000; year &lt;= 2000; year++) &#123; //判断1000~2000年之间year是否为闰年 //1.能被4整除,且不能被100整除,是闰年 //2.能被400整除是闰年 //if (year % 4 == 0 &amp;&amp; year % 100 != 0) //&#123; // printf(&quot;%d &quot;, year); // count++; //&#125; //else if (year % 400 == 0) //&#123; // printf(&quot;%d &quot;, year); // count++; //&#125; if (((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0)) &#123; printf(&quot;%d &quot;, year); count++; &#125; &#125; printf(&quot;\\ncount=%d\\n&quot;, count);//闰年的数量 return 0;&#125; 打印100~200之间的素数1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;math.h&gt; //数学库函数int main()&#123; int i = 0; int count = 0; for (i = 101; i &lt;= 200; i+=2) //从奇数中找更快 &#123; //判断i是否为素数 //素数判断的规则 //1.试除法 //产生2-&gt;i-1 int j = 0; for (j = 2; j &lt;=sqrt(i); j++) //库函数sqrt - 开平方 从开平方后的数中找，更快 &#123; if (i % j == 0) &#123; break; &#125; &#125; if (j &gt; sqrt(i)) &#123; printf(&quot;%d &quot;, i); count++; &#125; &#125; printf(&quot;\\ncount=%d &quot;, count); return 0;&#125; 找最大值1234567891011121314151617#include&lt;stdio.h&gt;int main()&#123; int arr[] = &#123; -1,-2,-3,-4,-5,-6,-7,-8,-9,-10 &#125;; //找最大值 int max = arr[0];//假设是最大值 int i = 0; int sz = sizeof(arr) / sizeof(arr[0]);//计算元素个数 = 数组总大小 / 每个元素的大小 for (i = 1; i &lt; sz; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; printf(&quot;max=%d &quot;, max); return 0;&#125; 打印9*9乘法口诀表123456789101112131415#include&lt;stdio.h&gt;int main()&#123; int a = 0; int b = 0; for (a = 1; a &lt;= 9; a++) &#123; for (b=1;b&lt;=a;b++) &#123; printf(&quot;%d*%d=%-2d &quot;, a, b, a * b);// %2d两位右对齐， %-2d两位左对其，位数不够自动空格填充 &#125; printf(&quot; \\n&quot;); &#125; return 0;&#125; 水仙花数求出0~100000之间的所有“水仙花数”并输出。 ———————— 自幂数“水仙花数”是指 一个n位数，其各位数字的n次方之和，恰好等于该数本身。如：153 &#x3D; 1^3+ 5^3+ 3^3 ,则 153 是一个 “水仙花数”。 123456789101112131415161718192021222324252627282930313233#include&lt;math.h&gt; //pow函数的头文件#include&lt;stdio.h&gt;int main()&#123; int i = 0; for (i = 0; i &lt;= 100000; i++) &#123; //判断i是否为自幂数 //1.计算i的位数 - n int n = 1; int tmp = i; while (tmp / 10) &#123; n++; tmp = tmp / 10; &#125; //2.计算i的每一位的n次方之和 tmp = i; int sum = 0; while (tmp) &#123; //pow函数是用来 求次方数 sum += pow(tmp % 10, n); tmp = tmp / 10; &#125; //判断 if (sum == i) &#123; printf(&quot;%d &quot;, i); &#125; &#125; return 0;&#125; 变种水仙花数变种水仙花数 - Lily Number：把任意的数字，从中间拆分成两个数字，比如1461 可以拆分成（1和461）,（14和61）,（146和1),如果所有拆分后的乘积之和等于自身，则是一个Lily Number。例如：655 &#x3D; 6 * 55 + 65 * 51461 &#x3D; 1*461 + 14*61 + 146*1求出 5位数中的所有 Lily Number。 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123; int i = 0; for (i = 10000; i &lt; 100000; i++) &#123; //所有的五位数中判断i是否为lily number int sum = 0; int j = 0; for (j = 1; j &lt;= 4; j++)//10的j次方 &#123; int m = i % (int)pow(10, j);//pow函数返回值为float，所以需要强制类型转换 int n = i / (int)pow(10, j);//pow(10 ,j) == 10的j次方 sum += m * n; &#125; if (sum == i) &#123; printf(&quot;%d &quot;, i); &#125; &#125; return 0;&#125; 打印菱形123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;int main()&#123; int line = 0; scanf(&quot;%d&quot;, &amp;line); int i = 0; //上 line行 for (i = 0; i &lt; line; i++) &#123; //打印一行 //空格 int j = 0; for (j = 0; j &lt; line - 1 - i; j++) &#123; printf(&quot; &quot;); &#125; //* for (j = 0; j &lt; 2 * i + 1; j++) &#123; printf(&quot;*&quot;); &#125; printf(&quot;\\n&quot;); &#125; //下 line-1行 for (i = 0; i &lt; line - 1; i++) &#123; //打印一行 //空格 int j = 0; for (j = 0; j &lt;= i; j++) &#123; printf(&quot; &quot;); &#125; //* for (j = 0; j &lt; 2 * (line - 1 - i) - 1; j++) &#123; printf(&quot;*&quot;); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 喝汽水20块钱买汽水，1元1瓶，2个空瓶可以换1瓶汽水，共能喝多少瓶？ 12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; int money = 0; int total = 0; scanf(&quot;%d&quot;, &amp;money); if (money &gt; 0) total = 2 * money - 1; //这种算法更好 //int total = money; //int empty = money; ////开始置换空瓶 //while (empty &gt;= 2) //常规 //&#123; // total += empty / 2; // empty = empty / 2 + empty % 2; //&#125; printf(&quot;%d\\n&quot;, total); return 0;&#125; 杨辉三角杨辉三角:11 11 2 11 3 3 11 4 6 4 11 5 10 10 5 1 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;int main()&#123; int arr[10][10] = &#123; 0 &#125;; int i = 0; int j = 0; int k = 0; for (i = 0; i &lt; 10; i++) &#123; for (j = 0; j &lt;= i; j++) &#123; if (j == 0 || i == j) &#123; arr[i][j] = 1; &#125; if (i &gt;= 2 &amp;&amp; j &gt;= 1) &#123; arr[i][j] = arr[i - 1][j - 1] + arr[i - 1][j]; &#125; &#125; &#125; for (i = 0; i &lt; 10; i++) &#123; if (i != 9) &#123; for (k = 9; k - i; k--) //这里是为了打印出来效果更像菱形 &#123; printf(&quot; &quot;); &#125; &#125; for (j = 0; j &lt;= i; j++) &#123; printf(&quot;%d &quot;, arr[i][j]); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 猜凶手4个杀人嫌疑犯的供词： A：不是我杀的 B：是C杀的 C：是D杀的 D：C在撒谎已知3个人在说真话，1个人在撒谎，请问凶手是谁？ 12345678910111213#include&lt;stdio.h&gt;int main()&#123; char killer = 0; for (killer = &#x27;A&#x27;; killer &lt;= &#x27;D&#x27;; killer++) &#123; if ((killer != &#x27;A&#x27;) + (killer == &#x27;C&#x27;) + (killer == &#x27;D&#x27;) + (killer != &#x27;D&#x27;) == 3) &#123; printf(&quot;%c\\n&quot;, killer);//每个表达式成立的话，得1，全部加起来为3的话，3个表达式成立 &#125; &#125; return 0;&#125; 比赛预测5名运动员比赛前进行预测： A：B第二，我第三 B：我第二，E第四 C：我第一，D第二 D：C最后，我第三 E：我第四，A第一比赛结束后，每个选手说对了一半，请确定每个选手的排名 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;int main()&#123; int a = 0; int b = 0; int c = 0; int d = 0; int e = 0; //每个选手的排名都可能是1~5之间 for (a = 1; a &lt;= 5; a++) &#123; for (b = 1; b &lt;= 5; b++) &#123; for (c = 1; c &lt;= 5; c++) &#123; for (d = 1; d &lt;= 5; d++) &#123; for (e = 1; e &lt;= 5; e++) &#123; if ( (b == 2) + (a == 3) == 1 &amp;&amp; (b == 2) + (e == 4) == 1 &amp;&amp; (c == 1) + (d == 2) == 1 &amp;&amp; (c == 5) + (d == 3) == 1 &amp;&amp; (e == 4) + (a == 1) == 1 ) //每个判断条件正确为1，错误为0，每个人只猜对一半的话，两个表达式相加等于1 &#123; if ((a * b * c * d * e) == 120) &#123; printf(&quot;a=%d b=%d c=%d d=%d e=%d\\n&quot;, a, b, c, d, e); //结果为：a=3 b=1 c=5 d=2 e=4 &#125; &#125; &#125; &#125; &#125; &#125; &#125; return 0;&#125; 其他1234567891011121314#include&lt;stdio.h&gt;int main()&#123; int i = 0; double sum = 0; int flag = 1; for (i = 1; i &lt;= 100; i++) &#123; sum += flag * 1.0 / i; //让每隔一次循环从 + 变 - ，再从 - 变 + flag = -flag; &#125; printf(&quot;%lf\\n&quot;, sum); return 0;&#125; 关机小程序1234567891011121314151617181920212223#include&lt;stdlib.h&gt; //system()的头文件#include&lt;stdio.h&gt;#include&lt;string.h&gt; //strcmp()的头文件int main()&#123; char input[20] = &#123; 0 &#125;; //shutdown -s -t 60 电脑在1分钟后关机 shutdown -a 取消关机 //cmd - command - 命令行 //system() - 执行系统命令的函数 system(&quot;shutdown -s -t 60&quot;);again: printf(&quot;请注意，你的电脑在1分钟后关机，如果输入：我是猪，就取消关机\\n请输入&gt;:&quot;); scanf(&quot;%s&quot;, input); if (strcmp(input, &quot;我是猪&quot;) == 0)//比较两个字符串 - strcmp() 比较字符串的函数 &#123; system(&quot;shutdown -a&quot;); &#125; else &#123; goto again; //可以用while循环代替，尽量不用goto &#125; return 0;&#125; goto语句 （尽量不要用） goto语句可以往前面或者后面跳，打乱程序的循序结构，容易进入死循环。不是必须时，不建议使用。 适合用goto语句的场合： 123456789101112131415for(...)&#123; for(...) &#123; for(....) &#123; if(disaster) goto error; //发生错误后，直接跳出到指定位置 &#125; &#125;&#125;...error: if(disaster) //处理错误情况 本章节完，感谢阅览！ 请持续关注我的更新~ 参考文献 https://github.com/soukenki","categories":[{"name":"C语言","slug":"C语言","permalink":"https://soukenki.github.io/zh-CN/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://soukenki.github.io/zh-CN/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"C语言-分支和循环-上","slug":"C语言-分支和循环-上","date":"2022-11-24T15:22:13.000Z","updated":"2022-11-29T03:28:34.487Z","comments":true,"path":"2022/11/25/C语言-分支和循环-上/","link":"","permalink":"https://soukenki.github.io/zh-CN/2022/11/25/C%E8%AF%AD%E8%A8%80-%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF-%E4%B8%8A/","excerpt":"关于本文章，介绍了C语言中的分支语句和循环语句，最后会附上例题练习题的题解哦~目录 &gt; 分支语句 if 语句 switch 语句 循环语句 while 循环 for 循环 do…while() 循环 练习题 二分查找算法","text":"关于本文章，介绍了C语言中的分支语句和循环语句，最后会附上例题练习题的题解哦~目录 &gt; 分支语句 if 语句 switch 语句 循环语句 while 循环 for 循环 do…while() 循环 练习题 二分查找算法 分支语句 if switch C语言是一门 结构化 的程序设计语言 顺序结构 （从头走到尾） 选择结构 （分支语句、选择语句）* 循环结构 （循环语句）* C语言中的真假：0为假，非0为真（-1也是真） if 语句 单分支： 112if(表达式) 语句;//表达式如果为真，语句也为真；否则，上面什么都不执行。 21234if(表达式) 语句1;//表达式如果为真，语句1会被执行；否则执行语句2。else 语句2; 多分支: 3123456if(表达式1) 语句1;else if(表达式2) //表达式1如果为真，语句1会被执行；否则执行语句2；再否则执行语句3。 语句2;else 语句3; //这里语句只能被执行1个。\\ 写法1： 12345678910111213141516#include&lt;stdio.h&gt;int main()&#123; int age = 45; if (age &lt; 18) printf(&quot;未成年\\n&quot;); else if (age &gt;= 18 &amp;&amp; age &lt; 28) printf(&quot;青年\\n&quot;); else if (age &gt;= 28 &amp;&amp; age &lt; 50) printf(&quot;壮年\\n&quot;); else if (age &gt;= 50 &amp;&amp; age &lt; 90) printf(&quot;老年\\n&quot;); else printf(&quot;老不死&quot;); return 0;&#125; 写法2： 12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; int age = 60; if (age &lt; 18) printf(&quot;未成年\\n&quot;); else &#123; if (age &gt;= 18 &amp;&amp; age &lt; 28) printf(&quot;青年\\n&quot;); else if (age &gt;= 28 &amp;&amp; age &lt; 50) printf(&quot;壮年\\n&quot;); else if (age &gt;= 50 &amp;&amp; age &lt; 90) printf(&quot;老年\\n&quot;); else printf(&quot;老不死&quot;); &#125; return 0;&#125; 两种写法完全一样的。如果条件成立，要执行多条语句，则使用代码块： 1234567891011#include&lt;stdio.h&gt;int main()&#123; int age = 10; if (age &lt; 18) &#123; printf(&quot;未成年\\n&quot;); printf(&quot;不能谈恋爱\\n&quot;); &#125; //这里的一对大括号&#123;&#125;叫做代码块 return 0;&#125; 对于新人很不友好的if语句问题：悬空 else问题 123456789101112#include&lt;stdio.h&gt; //要小心悬空elseint main()&#123; int a = 10; int b = 20; if (a == 0) //这里为假，后面的都不执行了。后面的else跟第二个if匹配，所以跟这里没有关系 if (b == 20) printf(&quot;hehe\\n&quot;); else printf(&quot;haha\\n&quot;); //else是跟离它最近的，未匹配的if，进行匹配。所以这里匹配的是第二个if return 0;&#125; //如果else想要和第一个if匹配，就用&#123;&#125;把第二个if和printf框起来 注意：else是跟离它最近的，未匹配的if，进行匹配。所以，适当的使用{}可以使代码的逻辑更加清楚。 if书写形式的对比： 代码11234if (condition) &#123; return x; &#125;return y; 代码212345678if(condition) &#123; return x; &#125;else&#123; return y; &#125; 代码2风格更好一点,可读性更强 判断相等时，反过来写风格更好： 1234567891011121314#include&lt;stdio.h&gt;int main()&#123; int num = 4; if (5 == num) //判断相等时，反过来写可以确保不会出错 &#123; printf(&quot;hehe\\n&quot;); &#125; //if (num = 5) // = 是赋值，== 判断相等 //&#123; // printf(&quot;呵呵\\n&quot;); //&#125; return 0;&#125; 练习：1，判断一个数是否为奇数2，输出1~100之间的奇数 12345678910111213141516171819202122#include&lt;stdio.h&gt;int main()&#123; //int b = 0; //while (b &lt;= 100) //&#123; // if (1 == b % 2) // printf(&quot;%d\\n&quot;, b); // b++; //&#125; int a = 1; while (a &lt;= 100) &#123; printf(&quot;%d &quot;, a); a += 2; //这种方式int a要=1，才能循环出奇数 &#125; if (1 == a % 2) &#123; printf(&quot;奇数\\n&quot;); &#125; return 0;&#125; switch 语句switch写法： 1234switch（整型表达式）//括号里必须要是整型&#123; 语句项； //语句项是一些case语句，case后面是 整型常量表达式 ：&#125; 例： 1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;int main()&#123; int day = 0; scanf(&quot;%d&quot;, &amp;day);//在scanf进行输入的时候，如果遇到空格，就会结束输入。 switch (day) &#123; case 1: printf(&quot;星期1\\n&quot;); break; //break中断语句，直接跳到&#125;后面 case 2: printf(&quot;星期2\\n&quot;); break; case 3: printf(&quot;星期3\\n&quot;); break; default: //默认，输入没有的选项时，尽量每次case语句项都加default和break printf(&quot;输入错误\\n&quot;);//可以是空白 break; &#125; //switch (day) //&#123; //case 1: //case 2: //case 3: //case 4: // printf(&quot;工作日\\n&quot;);//输入1~4都会显示工作日，语句项可以为空白 // break; //case 5: //case 6: // printf(&quot;休息日\\n&quot;); // break; //即使是最后一个，最好也加上break //&#125; return 0;&#125; default 在case语句项中没有规定位置，前后都可以用if 在case语句项中可以被使用 练习： 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main()&#123; int n = 1; int m = 2; switch (n) &#123; case 1: m++; case 2: n++; case 3: switch (n) &#123;//switch允许嵌套使用 case 1: n++; //运行到case3的switch(n)时，以n为入口，这时的n=2,所以直接走case3里的case2 case 2: m++; n++; break; &#125; case 4: m++; break; default: break; &#125; printf(&quot;m = %d, n = %d\\n&quot;, m, n);//结果为m=5 n=3 return 0;&#125; 循环语句 while for do while while 循环写法： 12while(表达式) //表达式为真，运行循环语句 循环语句; 例1234567#include&lt;stdio.h&gt;int main()&#123; while (1) //这里把if语句的if换成while，变成死循环 printf(&quot;hehe\\n&quot;); return 0;&#125; break 中止; continue 继续; 123456789101112131415#include&lt;stdio.h&gt;int main()&#123; int i = 1; while (i &lt;= 10) &#123; if (i == 9) break; //break用于永久中止循环。i循环到5时，停止循环，直接跳到 &#125; ，所以没有经过printf，就没有打印出来 if (i == 5) continue;//continue用于中止本次循环，（后面的printf本次不打印）回到上面while重新开始循环 printf(&quot;%d &quot;,i); i++; &#125; return 0;&#125; scanf();遇到’\\n’结束,’\\n’前面的数据会被取走. int ch &#x3D; getchar() 输入一个字符 getchar函数的返回值是int类型，因为返回的是字符的ASCII码值。 因为是从缓冲区中读取字符，需要先清空缓冲区 清空缓冲区的方法： 12345int tmp = 0;while((tmp = getchar()) != &#x27;\\n&#x27;)&#123; ;&#125; getchar()每工作一次,就会从缓冲区中取走一个字符 putchar(ch) 打印字符 读取int类型ch的值，打印对应的ASCII码值的字符 练习：while((ch&#x3D;getchar()) !&#x3D;EOF) &#x2F;&#x2F; 创建循环输入 123456789101112131415161718192021222324#include&lt;stdio.h&gt;int main()&#123; int ch = 0; //ctrl + z while ((ch = getchar()) !=EOF) //EOF - end of file -&gt; 值为-1 （文件结束标志） &#123; putchar(ch); &#125; //int ch = getchar(); //输入 //putchar(ch); //输出，与printf函数一样 //用法1： //while((ch=getchar()) !=&#x27;\\n&#x27;) //当我们用printf打印之后，会在输入缓冲区剩下东西，这个代码可以帮助我们清空 //&#123; //循环读取缓冲区的数，直到不等于&#x27;\\n&#x27;，这时缓冲区被清空，跳出循环 // ; //&#125; //用法2： //while((ch=getchar()) !=EOF) //创建循环输入 //&#123; // if(ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;) //ch小于0并且大于9的值，全部跳过本次循环 // continue; //所以这里 只有0~9可以被输出 // putchar(ch); //&#125; return 0;&#125; 以下三个要素是循环最重要的 12345while三要素：int i =0; //初始化 while(i&lt;10) //判断&#123; i++； //调整&#125; 后期代码越多，三个要素隔得越开，不方便调节。所以衍生出for循环 for 循环12for(表达式1；表达式2；表达式3) //表达式1：初始化；表达式2：判断；表达式3：调整。 循环语句; //循序：1-&gt;2-&gt;循环语句-&gt;3-&gt;2-&gt;循环语句-&gt;3-&gt;2... 这里continue只会跳过循环语句，不会跳过表达式3 使用例：123456789101112131415#include&lt;stdio.h&gt;int main()&#123; int i = 0; // 初始化 判断 调整 三要素一起合在for循环中 for (i = 0;i &lt;= 10;i++) &#123; //if (i == 5) // break; //这里break也是中止整个循环，跳到&#125; if (i == 5) continue; //这里continue也是中止本次循环，跳到&#125; ,但不会死循环 printf(&quot;%d &quot;, i); &#125; return 0;&#125; 建议： 不可在for 循环体内修改循环变量，防止 for 循环失去控制。 (不要给变量’&#x3D;‘赋值) 建议for 语句的循环控制变量的取值采用“前闭后开区间”写法。(for(i&#x3D;0;i&lt;10;i++)这种写法比较好，尽量别写i&lt;&#x3D;9，虽然打印出来效果一样) for的变种1： 1234for(;;)&#123; printf(&quot;hehe&quot;);&#125; for循环的初始化、判断、调整 都可以省略。但是、for循环的判断部分如果被省略，那判断条件就是：恒为真 如果不是非常熟练，建议大家不要随便省略变种例：12345678910111213#include&lt;stdio.h&gt;int main()&#123; //for(;;) int a = 0; int b = 0; for (a=0;a&lt;10;a++) //得出的结果为：100次hehe &#123; //但是，如果省略a=0和b=0的话，只会打出10个hehe。 for(b=0;b&lt;10;b++) //因为当第2个for结束循环时，b=10，第1个for循环进去，b为假，又跳出来，所以不会发生改变 printf(&quot;hehe\\n&quot;); &#125; return 0;&#125; for的变种2： 12345678910#include&lt;stdio.h&gt;int main()&#123; int x, y; for (x = 0, y = 0; x &lt; 2 &amp;&amp; y &lt; 5; ++x, y++) //++不管前置还是后置都是加一 &#123; printf(&quot;hehe\\n&quot;); //得两个hehe，第三次x=2，为假，跳出循环 &#125; return 0;&#125; for (i &#x3D; 0, k &#x3D; 0; k &#x3D; 0 ; i++, k++) 第二个表达式一个&#x3D;是赋值，所以表达式2为0，判断为0的话，表达式为假直接跳出循环，所以循环0次 do…while() 循环do语句得语法： 12345do&#123; 循环语句；&#125;while(表达式); 例：12345678910111213141516#include&lt;stdio.h&gt;int main()&#123; int i = 1; do &#123; //if (i == 5) // break; //结果为：1 2 3 4，中止整个循环 //if (i == 5) // continue; //结果为：1 2 3 4 死循环 printf(&quot;%d &quot;, i); i++; &#125; while (i &lt;= 10); return 0;&#125; 练习题阶乘123456789101112131415int main()&#123; int a = 0; int b = 0; int ret = 1; int sum = 0; for (b = 1; b &lt;= 10; b++) &#123; ret = ret * b; //b的阶乘 sum = sum + ret; &#125; printf(&quot;sum=%d\\n&quot;, sum); return 0;&#125; 写一个代码，在arr数组（有序的）中找到XXX 1234567891011121314151617181920#include&lt;stdio.h&gt;int main()&#123; int arr[] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;; int k = 7; //写一个代码，在arr数组（有序的）中找到7 int i = 0; int sz = sizeof(arr) / sizeof(arr[0]); //计算元素个数 = 数组总大小 / 每个元素的大小 for (i = 0; i &lt; sz; i++) &#123; if (k == arr[i]) &#123; printf(&quot;找到了，下标是：%d \\n&quot;, i); break; &#125; &#125; if (i == sz) printf(&quot;找不到\\n&quot;); return 0;&#125; 二分查找算法折半查找算法,二分查找算法 （必须要是 有序数组，才可以用二分查找） 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;int main()&#123; int arr[] = &#123; 1,2,3,4,5,6,8,9,10 &#125;; int k = 7; //要找的数 int sz = sizeof(arr) / sizeof(arr[0]);//计算元素个数 = 数组总大小 / 每个元素的大小 int left = 0; //左下标 int right = sz - 1; //右下标 while (left &lt;= right) //条件: 左 &lt;= 右 &#123; int mid = (left + right) / 2; //中间元素的下标 （这种算法不够好，如果左右的值太大，相加起来可能会越界） // int mid = left + (right - left) / 2; //这样算法更好，不会越界访问，也能求出平均值 // int mid = left + ((right - left)&gt;&gt; 1); //这种也好，二进制位右移1，则相当于除了2 if (arr[mid] &gt; k) &#123; right = mid - 1; //折中后的右下标 &#125; else if (arr[mid] &lt; k) &#123; left = mid + 1; //折中后的左下标 &#125; else &#123; printf(&quot;找到了,下标是: %d\\n&quot;, mid); //折中后的中点 break; &#125; &#125; if (left &gt; right) //条件:左 &gt; 右 (增加稳定性) &#123; printf(&quot;找不到\\n&quot;); &#125; return 0;&#125; （本篇分支和循环语法介绍结束，更多练习题题解请继续浏览《C语言-分支和循环-下》） 参考文献 https://github.com/soukenki 分支语句结构图出自：https://www.cnblogs.com/wlfya/p/14003562.html 循环语句结构图出自：https://www.lidihuo.com/python/python-for.html","categories":[{"name":"C语言","slug":"C语言","permalink":"https://soukenki.github.io/zh-CN/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语法","slug":"C语法","permalink":"https://soukenki.github.io/zh-CN/tags/C%E8%AF%AD%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"https://soukenki.github.io/zh-CN/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"C语言的初次见面-下","slug":"C语言的初次见面-下","date":"2022-11-23T12:11:53.000Z","updated":"2022-11-24T15:18:48.754Z","comments":true,"path":"2022/11/23/C语言的初次见面-下/","link":"","permalink":"https://soukenki.github.io/zh-CN/2022/11/23/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%88%9D%E6%AC%A1%E8%A7%81%E9%9D%A2-%E4%B8%8B/","excerpt":"关于本文章，是我第一次接触C的时候，大概了解到的一个框架。这里是文章的下半部分，后面我会更新发布专门针对各种各样关于语法细节的文章。感兴趣的话，请持续关注我的更新~目录 &gt; 函数 数组 操作符 算术操作符： + - * &#x2F; % 移位操作符: &gt;&gt; &lt;&lt; 位操作符：&amp;按位与、|按位或、^按位异或 赋值操作符： &#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D; &gt;&gt;&#x3D; &lt;&lt;&#x3D; 单目操作符: ! + - sizeof ~ ++ – &amp; * (类型) 关系操作符: &gt; &gt;&#x3D; &lt; &lt;&#x3D; !&#x3D; &#x3D;&#x3D; 逻辑操作符 条件操作符（三目操作符） 逗号表达式 下标引用、函数调用和结构成员 常见关键字 指针 结构体","text":"关于本文章，是我第一次接触C的时候，大概了解到的一个框架。这里是文章的下半部分，后面我会更新发布专门针对各种各样关于语法细节的文章。感兴趣的话，请持续关注我的更新~目录 &gt; 函数 数组 操作符 算术操作符： + - * &#x2F; % 移位操作符: &gt;&gt; &lt;&lt; 位操作符：&amp;按位与、|按位或、^按位异或 赋值操作符： &#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D; &gt;&gt;&#x3D; &lt;&lt;&#x3D; 单目操作符: ! + - sizeof ~ ++ – &amp; * (类型) 关系操作符: &gt; &gt;&#x3D; &lt; &lt;&#x3D; !&#x3D; &#x3D;&#x3D; 逻辑操作符 条件操作符（三目操作符） 逗号表达式 下标引用、函数调用和结构成员 常见关键字 指针 结构体 函数函数例：12345678910111213141516171819#include&lt;stdio.h&gt; //printf、scanf这些是库函数，C语言库自带的int add(int x, int y) //int add 这种是自定义函数，自己设计的&#123; int z = (x + y); //设计的计算公式（自己设计，加减乘除都行） return z; //这里计算结果会返回到下面的sum里&#125;int main()&#123; int num1 = 100; int num2 = 200; int sum = 0; int a = 5; int b = 6; sum = add(num1, num2);//得出结果300 printf(&quot;%d\\n&quot;, sum); sum = add(a, b); printf(&quot;%d\\n&quot;, sum);//得出结果11 return 0;&#125; 数组123456789101112131415161718#include&lt;stdio.h&gt;int main()&#123; //定义一个存放10个整型数字的数组 int arr[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;;//下标从0开始，比如[n]的下标=n-1 //0~9 int i = 0; while (i &lt; 10) &#123; printf(&quot;%d &quot;, arr[i]); i++; //用循环语句再加上++，从而打出1~10的全部数值 &#125; printf(&quot;%d\\n&quot;, arr[4]);//用下标的形式访问元素 arr[下标]； char ch[20];//存放字符 float arr2[5];//存放浮点数字 return 0;&#125; 操作符 算术操作符： + - * &#x2F; % 移位操作符: &gt;&gt; &lt;&lt; 位操作符：&amp;按位与、|按位或、^按位异或 赋值操作符： &#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D; &gt;&gt;&#x3D; &lt;&lt;&#x3D; 单目操作符: ! + - sizeof ~ ++ – &amp; * (类型) 关系操作符: &gt; &gt;&#x3D; &lt; &lt;&#x3D; !&#x3D; &#x3D;&#x3D; 逻辑操作符 条件操作符（三目操作符） 逗号表达式 算术操作符： + - * &#x2F; %12345678#include&lt;stdio.h&gt;int main()&#123; // 5/2=2余数为1: 5/2--&gt;2 5%2--&gt;1 int a = 5 % 2;// %用于取模(余数) printf(&quot;%d\\n&quot;, a);// 1 return 0;&#125; 移位操作符: &gt;&gt; &lt;&lt;1234567891011121314#include&lt;stdio.h&gt;int main()&#123; //移（2进制）位操作符 // &lt;&lt;左移 &gt;&gt;右移 int a = 1; //整型1占4个字节-32bit位 //00000000000000000000000000000001 int b = a &lt;&lt; 3;//a左移3个bit位等于b //b=00000000000000000000000000001000 //计算公式: 1*2^3 + 0*2^2 + 0*2^1 + 0*2^0 = 8+0+0+0 = 8 printf(&quot;%d\\n&quot;, b);//得出b=8 return 0;&#125; 位操作符：&amp;按位与、|按位或、^按位异或12345678910111213141516171819202122232425#include&lt;stdio.h&gt;int main()&#123; //（2进制）位操作 二进制： ... 1 1 1 1 // &amp; 按位与 ... 1*2^3 1*2^3 1*2^3 1*2^3 // | 按位或 ... 8 4 2 1 // ^ 按位异或 int a = 3; //011--&gt; 1*2^1 + 1*2^0 = 2+1 = 3----2+1----0011 int b = 5; //5-----4+1-----0101 例： 13-----8+4+1----1101 int c = a &amp; b;//得1 // &amp; 011 0+1-0 ，1+1-1 必须两个1才得1 // 101 //得出 001 int c = a | b;//得7 // | 011 0+1-1 ，1+1-1 只要有一个1就得1 // 101 //得出 111 int c = a ^ b;//得6 //异或的计算规律：对应的二进制位相同，则为0; 对应的二进制位相异，则为1。 // ^ 011 // 101 //得出 110 printf(&quot;%d\\n&quot;, c); return 0;&#125; 赋值操作符： &#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D; &gt;&gt;&#x3D; &lt;&lt;&#x3D;12345678910111213141516int main()&#123; int a = 10; a = 20;// &#x27;=&#x27; 赋值 &#x27;==&#x27; 判断相等 a = a + 10;//方式1 a += 10; //方式2 方式1和2，完全相等 //例 a = a - 20; a -= 20; a = a &amp; 2; a &amp;= 2; //复合赋值符 //+= -= *= %= &gt;&gt;= &lt;&lt;= &amp;= |= ^= return 0;&#125; 单目操作符: ! + - sizeof ~ ++ – &amp; * (类型) 单目操作符 （一个操作数） 双目操作符 （两个操作数） 三目操作符 (三个操作数) ! 反逻辑操作符 12345678910111213//C语言中表示我们表示真假 // 0-假 非0-真 int a = 10; printf(&quot;%d\\n&quot;, a);//正常逻辑a=10为真 printf(&quot;%d\\n&quot;, !a);//前面加&#x27;！&#x27;逻辑反逻辑，&#x27;!a&#x27;为0，是假。 !的应用场景: if(a) printf(&quot;hehe\\n&quot;); if(!a) printf(&quot;hehe\\n&quot;); //如果&#x27;a&#x27;=&#x27;0&#x27;，则&#x27;!a&#x27;为&#x27;1&#x27;。 + 正值 、 - 负值 123int a = 2;// 2int b = -a;// -2 给a取负int c = +b;// -2 +正号都会省略 sizeof 操作数的类型长度（以字节为单位） 12345678910111213141516 int a = 10; //sizeof 计算的是 变量或类型 所占空间的大小，单位是字节 printf(&quot;%d\\n&quot;, sizeof(a)); //4 几个方式都一样 printf(&quot;%d\\n&quot;, sizeof(int));//4 printf(&quot;%d\\n&quot;, sizeof a); //4 a的()可以省略 //printf(&quot;%d\\n&quot;, sizeof int);//error int的&#x27;()&#x27;不可省略，所以是error——————————————————————————————————————————————————————————————————————————— int arr[10] = &#123; 0 &#125;;//10个整型元素的数组 //10*sizeof(int) = 40 printf(&quot;%d\\n&quot;, sizeof arr);//40 //计算数组的元素个数 // 个数 = 数组总大小 / 每个元素的大小 int sz = 0; sz = sizeof(arr) / sizeof(arr[0]); printf(&quot;sz=%d\\n&quot;, sz);//10 EOF - end of file - 文件结束标志&#x3D; -1 #define EOF -1 练习题12345678910111213141516171819202122#include&lt;stdio.h&gt; int max(int x, int y) //自定义函数&#123; if (x &gt; y) return x; //如果x&gt;y，显示x else return y; //其他显示y&#125;int main()&#123; int a = 10; int b = 20; int c = 0; c = max(a, b); printf(&quot;c=%d\\n&quot;, c);//得20，显示b的值———————————————————————————————————————————————————————————————————— int arr[] = &#123; 1,2,3,4,5,6 &#125;;// 6*4=24 （1个int，4个字节--&gt;6个数，6个int） printf(&quot;%d\\n&quot;, sizeof(arr));//计算数组大小，单位是字节 printf(&quot;%d\\n&quot;, sizeof(arr) / sizeof(arr[0])); //arr的总大小除于（arr[0]）一个元素的大小= 元素个数--&gt;6 return 0;&#125; ~ 对一个数的二进制按位取反 12345678910#include&lt;stdio.h&gt;int main()&#123; int a = 0;//4个字节，32个bit位---&gt;00000000000000000000000000000000(32个) int b = ~a; // ~ 按（二进制）位取反 例：1010 --&gt;0101 （1和0互相改变） b是有符号的整型 //按位取反后变成32个 1，b=32个1 printf(&quot;%d\\n&quot;, b);// -1 因为b是有符号的整型，所以第一位数是符号位，当它是1时变负号（-） //计算机存储负数时，用的是 补码， 但是使用时，打印的是这个数的原码。 return 0;&#125; 原码、反码、补码 负数在内存中存储的时候，存储的是二进制的 补码 原码 -&gt; 反码 -&gt; 补码 的过程： 原码-&gt; 符号位不变，其他位置按位取反 –&gt; 反码 反码-&gt; 加一（+1）–&gt; 补码 反过来就是：补码-1 再 按位取反 &#x3D; 原码 所以 11111111111111111111111111111111 11111111111111111111111111111110 符号位不变 10000000000000000000000000000001 符号位1&#x3D;负号 0000000000000000000000000000001&#x3D;1 所以得出b&#x3D; -1 只要是整数，内存中存储的都是二进制的补码正数–原码，反码，补码 相同负数–&gt;补码原码是：直接按照正负写出的二进制序列 -2 100000000000000000000010 -2的原码反码是：原码的符号位不变，其他位置按位取反 111111111111111111111101 -2的反码补码是：反码+1 111111111111111111111110 -2的补码 ++ -- 前置 或 后置 ++ -- 1234567891011#include&lt;stdio.h&gt;int main()&#123; int a = 10; //int b = a++;//后置++，先使用(b变a)，再++(a再+1) int b = ++a;//前置++，先++（a+1），再使用 //int b = a--;//a=9,b=10 //int b = --a;//a=9,b=9 printf(&quot;a=%d b=%d\\n&quot;, a, b);//后置++：a=11,b=10； 前置++：a=11，b=11。 return 0;&#125; &amp; 取地址 * 间接访问操作符（解引用操作符） （类型） 强制类型转换 ‘（）里面放个类型’ 12345int main()&#123; int a = (int)3.14;//原来3.14是double类型的，（）里面填类型，强制类型转换，让3.14强制变int类型 return 0;&#125; 关系操作符: &gt; &gt;&#x3D; &lt; &lt;&#x3D; !&#x3D; &#x3D;&#x3D; &gt; 大于 &gt;&#x3D; 大于等于 &lt; 小于 &lt;&#x3D; 小于等于 !&#x3D; 不等于 — 用于测试‘不等于’ &#x3D;&#x3D; 判断相等 — 用于测试‘相等’ — 一个&#x3D;是赋值操作符 逻辑操作符&amp;&amp; 逻辑与|| 逻辑或 1234567891011121314151617#include&lt;stdio.h&gt;int main()&#123; // 假--0 真--非0 // &amp;&amp; - 逻辑与 int a = 3; int b = 5; int c = a &amp;&amp; b;//左边a为真，右边b也为真，所以c也为真（只要a或b其中一个为假（0），那么c也为假（0）） printf(&quot;c=%d\\n&quot;, c);// c为真--&gt;1 c为假--&gt;0 // ||-逻辑或 int e = 0; int f = 2; int g = e || f;//只要e 或 f其中一个为真，则g为真。 printf(&quot;g=%d\\n&quot;, g);//g=1 e和f都为假（0），g才为假 return 0;&#125; 条件操作符（三目操作符）exp1 ? exp2 : exp3 1234567891011121314#include&lt;stdio.h&gt;int main()&#123; int a = 10; //exp1?exp2:exp3; 表达式1为真，结果为表达式2；表达式1为假，则为表达式3。 int b = 20; int max = 0; max = (a &gt; b ? a : b);//a&gt;b为真，max得a；a&gt;b为假，max则得b。 //if (a &gt; b) // max = a; //上面这个三目操作符可以代替if和else来简洁使用 //else // max = b; printf(&quot;max=%d\\n&quot;, max); return 0;&#125; 逗号表达式exp1 , exp2 , exp3 , … expN逗号表达式，从左到右依次计算，整个 表达式的结果 是：最后一个表达式的结果。 例：12345int a = 1;int b = 3;int c = 4;int d = (a = b - 3 , b = a * 2 , c = a - b);// 0 a b c 的值都会被改变printf(&quot;%d\\n&quot;,d);// 0 下标引用、函数调用和结构成员 [] () . -&gt; 12345678910111213141516171819#include&lt;stdio.h&gt;int Add(int x, int y)&#123; int z = 0; z = x + y; return z;&#125;int main()&#123; //int arr[10] = &#123; 0 &#125;; //arr[4];// [] - 下标引用操作符 操作数: arr 和 4 int a = 10; int b = 20; int sum = Add(a, b);// () - 函数调用操作符 操作数: 函数名Add 和 函数的参数a 和 函数参数b printf(&quot;sum=%d\\n&quot;, sum); return 0; // &amp; * 指针部分文章介绍 // . -&gt; 结构体部分文章介绍 &#125; 常见关键字12345678auto 自动 break 中断 case char字符类型 const 常变量 continue 继续 default 默认 do double 类型 else enum 枚举extern 引入(声明)外部符号 float for goto if int long register 寄存器关键字 return 返回 short signed 有符号数 sizeof static 静态的 struct 结构体关键字 switch typedef 类型定义 union 联合体/共用体 unsigned 无符号数 void 无/空 volatile while 循环 auto int a &#x3D; 10;&#x2F;&#x2F;局部变量都是自动变量，所以int前面默认省略auto register int a &#x3D; 10;&#x2F;&#x2F;起到一个建议的作用，建议把a定义成 寄存器变量，最终是由编译器决定寄存器变量不能取地址！！ int a &#x3D;10;&#x2F;&#x2F; signed int 只是把signed省略掉了。int 定义的变量是有符号的数a &#x3D; -2; &#x2F;&#x2F;所以a可以是-2unsigned int b &#x3D; 0;&#x2F;&#x2F;无符号数，这个数字永远是正数 #define是宏定义，仅仅是直接替换,INT_PTR a, b; 进行宏替换后代码是这样的：int *a, b;这里的int *是a的类型，b的类型是int，故此次b只是int类型。而typedef是把该类型定义一个别名，别名是一个独立的类型了，使用这个 类型创建的变量都是这个类型的。 关键字 typedef (类型定义)-类型重定义typedef unsigned int u_int;&#x2F;&#x2F;给unsigned加个别名，叫：u_intunsigned int num &#x3D; 20;&#x2F;&#x2F;所以用起来一模一样u_int num2 &#x3D; 20; 关键字 static - 静态的 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;1. static 修饰局部变量//从内存的 栈区 变成 储存到内存的 静态区//使局部变量的生命周期变长 --&gt; 变成和程序的生命周期一样 但 作用域不变2. static 修饰全局变量 另一个源文件里static int g_val = 2020;//全局变量是有外部链接属性的 .c文件-&gt;编译-&gt;链接-&gt;可执行文件(exe)//全局变量原本是外部链接属性,static修饰之后,变成内部链接属性.//改变了全局变量的作用域 static静态的全局变量只能在自己所在的源文件内部使用，出了源文件就无法再使用了3. static 修饰函数//也是改变了函数的作用域-不准确//static 修饰函数改变了函数的链接属性//外部链接属性--&gt;内部链接属性 static修饰之后,只能在本源文件内部使用,其他源文件不能使用(修饰函数和修饰全局变量,概念一样)void test()&#123; static int a = 1;//a是一个静态的局部变量 a++; printf(&quot;a=%d\\n&quot;, a);//2 3 4 5 6&#125;//声明外部函数extern int Add(int, int);int main()&#123; int i = 0; while (i &lt; 5) &#123; test(); i++; &#125; //extern - 声明外部符号的 extern int g_val; printf(&quot;g_val=%d\\n&quot;, g_val);//error 另一个源文件里的全局变量static int g_val出了源文件就无法再使用 int a = 10; int b = 20; int sum = Add(a, b); printf(&quot;sum=%d\\n&quot;, sum);//error 另一个源文件里的Add函数被static了 return 0;&#125; #define 定义常量和宏 1234567891011121314151617181920212223242526272829//#define 定义标识符常量//#define MAX 100//#define STR &quot;hehe&quot;//#define 可以定义宏 - 带参数#include&lt;stdio.h&gt;int Max(int x, int y)&#123; if (x &gt; y) return x; else return y;&#125;//宏的定义方式 宏名字用全大写#define MAX(X,Y) (X&gt;Y?X:Y) //宏，变成后面的公式 比自定义函数更简洁//#define ADD(x,y) ((x)+(y)) //宏是有参数的,类似函数的感觉 带括号保证兼容性(参数可能会是公式)int main()&#123; //int a = MAX; int a = 10; int b = 20; //函数 int max = Max(a, b); printf(&quot;max=%d\\n&quot;, max); //宏的方式 max = MAX(a, b); //max=(a&gt;b?a:b); 因为宏的定义，变成这个公式 printf(&quot;max=%d\\n&quot;, max); return 0;&#125; 指针 内存会被划分为小的内存单元，一个内存单元大小是1个字节 每个内存单元都有编号，这个编号被称为：地址&#x2F;指针 地址&#x2F;指针就可以存放在一个变量中，这个变量被称为：指针变量 通过指针变量中存放的地址，就能找到指针指向的空间12345678910111213#include&lt;stdio.h&gt;int main()&#123; int a = 10;//4个字节 int* p = &amp;a;//取地址 int* - 指针变量 printf(&quot;%p\\n&quot;, &amp;a); printf(&quot;%p\\n&quot;, p); *p = 20;// * - 解引用操作符 / 间接访问操作符 原本*p这个地址是数值是10，这里的=20是把*p地址的数改成20 printf(&quot;%d\\n&quot;, a);//则int a也变20 //有一种变量是用来存放地址的 - 指针变量 //printf(&quot;%p\\n&quot;, &amp;a); return 0;&#125; 指针的大小1234567891011121314#include&lt;stdio.h&gt;int main()&#123; char ch = &#x27;w&#x27;; char* pc = &amp;ch;//根据类型不同，指针随之改变 printf(&quot;%d\\n&quot;, sizeof(pc));//4 个字节（32位平台） 如果是8个字节，则64位平台 //*pc = &#x27;a&#x27;; //printf(&quot;%c\\n&quot;, ch); printf(&quot;%d\\n&quot;, sizeof(char*));//4 printf(&quot;%d\\n&quot;, sizeof(short*));//4 printf(&quot;%d\\n&quot;, sizeof(int*));//4 printf(&quot;%d\\n&quot;, sizeof(double*));//4 只要是32位平台，什么类型都是4 return 0;&#125; 结构体复杂对象 - 结构体 - 我们自己创造出来的一种类型 1234567891011121314151617181920212223//创建一个结构体类型#include&lt;stdio.h&gt;struct Book&#123; char name[20];//C语言程序设计 short price;//55&#125;; //;分号不可确少int main()&#123; //利用结构体类型 - 创建一个改类型的变量 struct Book b1 = &#123; &quot;C语言程序设计&quot;,55 &#125;; printf(&quot;书名：%s\\n&quot;, b1.name); printf(&quot;价格：%d元\\n&quot;, b1.price); b1.price = 15; //可以直接修改 printf(&quot;修改后的价格：%d元\\n&quot;, b1.price); struct Book* pb = &amp;b1;//这里定义了一个指针类型struct Book 名叫 pb //利用pb打印出我的书名和价格 //printf(&quot;%s\\n&quot;, (*pb).name);//方法1 .结构体变量.成员 //printf(&quot;%d\\n&quot;, (*pb).price);//(*pb)的（）是为了系统不要误会*pb.name是一个指针变量 printf(&quot;%s\\n&quot;, pb-&gt;name);//方法2 -&gt;结构体指针-&gt;成员 printf(&quot;%d\\n&quot;, pb-&gt;price); return 0;&#125; 字符串修改（例：修改上面这个书名） 12345678#include&lt;string.h&gt; //增加一个string.h头函数int main()&#123; struct Book b1 = &#123; &quot;C语言程序设计&quot;,55 &#125;; strcpy(b1.name, &quot;C++&quot;);//strcpy - string copy - 字符串拷贝-库函数-string.h printf(&quot;%s\\n&quot;, b1.name); return 0;&#125; 本章节完，感谢阅览！后面我会更新发布专门针对各种各样关于语法细节的文章。感兴趣的话，请持续关注我的更新~ 参考文献 https://github.com/soukenki","categories":[{"name":"C语言","slug":"C语言","permalink":"https://soukenki.github.io/zh-CN/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语法","slug":"C语法","permalink":"https://soukenki.github.io/zh-CN/tags/C%E8%AF%AD%E6%B3%95/"}]},{"title":"C语言的初次见面-上","slug":"C语言的初次见面-上","date":"2022-11-22T15:45:25.000Z","updated":"2022-12-09T11:01:45.225Z","comments":true,"path":"2022/11/23/C语言的初次见面-上/","link":"","permalink":"https://soukenki.github.io/zh-CN/2022/11/23/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%88%9D%E6%AC%A1%E8%A7%81%E9%9D%A2-%E4%B8%8A/","excerpt":"关于本文章，是我第一次接触C的时候，大概了解到的一个框架。比如，本文中的循环只简单介绍了while。这里是文章的上半部分，后面我会更新发布专门针对各种各样关于不同语法细节的文章。感兴趣的话，请持续关注我的更新~ 目录 &gt; 我的第一个C代码 数据类型 实用的函数printf()的形式 计算机中的单位 变量和常量 计算两个数值的和 变量的作用域 变量的生命周期 常量（字面常量）（const修饰的常变量） 常量（#define定义的标识符常量） 常量（枚举常量） 字符串 计算字符串长度 strlen(); 转义字符 ‘\\ddd’ 8进制 ‘\\xdd’ 16进制 注释 选择语句 循环语句","text":"关于本文章，是我第一次接触C的时候，大概了解到的一个框架。比如，本文中的循环只简单介绍了while。这里是文章的上半部分，后面我会更新发布专门针对各种各样关于不同语法细节的文章。感兴趣的话，请持续关注我的更新~ 目录 &gt; 我的第一个C代码 数据类型 实用的函数printf()的形式 计算机中的单位 变量和常量 计算两个数值的和 变量的作用域 变量的生命周期 常量（字面常量）（const修饰的常变量） 常量（#define定义的标识符常量） 常量（枚举常量） 字符串 计算字符串长度 strlen(); 转义字符 ‘\\ddd’ 8进制 ‘\\xdd’ 16进制 注释 选择语句 循环语句 我的第一个C代码 .c文件为 C语言源文件 .h文件为 头文件 包含一个叫stdio.h的文件 std-标准 standard标准 input输入 output输出 123456789101112#include&lt;stdio.h&gt;// int是整型的意思，main前面的int表示main函数调用之后返回整型值int main() // 主函数--&gt;程序入口--&gt;有却只有一个&#123; /* 这里做任务,输入函数 函数-print function - printf - 打印函数 */ printf(&quot;hello 你好\\n&quot;); return 0; &#125; 数据类型 名称 数据类型 大小 char 字符数据类型 1 short 短整型 2 int 整型 4 long 长整型 4 或 8 long long 更长的整型 8 float 单精度浮点数 4 double 双精度浮点数 8 使用float初始化数据时，在数据后面加上f，编译器默认为double类型，加f让它为float 字符初始化: ‘w’ 字符串初始化: “Name” -&gt; 注意符号区分 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;int main()&#123; char ch = &#x27;A&#x27;; //char--字符类型 printf(&quot;%c\\n&quot;,ch); // %c--打印字符格式的数据 \\n--换行的意思 /* %f--打印浮点数字（打小数） %p--以地址的形式打印 %x--打印十六进制数字 %o....*/ //short int //短整型 int age = 20; //整型 printf(&quot;%d\\n&quot;, age); // %d--打印整型十进制数据 //long 长整型 long nom = 11100; printf(&quot;%d\\n&quot;, nom); float f = 5.2; //单精度浮点数 printf(&quot;%f\\n&quot;, f); double d = 3.14; //双精度浮点数 printf(&quot;%lf\\n&quot;, d);//打印双精度浮点数时，用%f可能会丢失精度，所以用%lf更为合适 //sizeof是用来计算括号起来东西的大小 printf(&quot;%d\\n&quot;, sizeof(char)); //1 printf(&quot;%d\\n&quot;, sizeof(short));//2 printf(&quot;%d\\n&quot;, sizeof(int));//4 printf(&quot;%d\\n&quot;, sizeof(long));// 4/8 C语言标准sizeof(long) &gt;或= sizeof(int) 都行,4=4 8&gt;4 printf(&quot;%d\\n&quot;, sizeof(long long));//8 printf(&quot;%d\\n&quot;, sizeof(float));//4 printf(&quot;%d\\n&quot;, sizeof(double));//8 return 0;&#125; 实用的函数printf()的形式 类型 标志 输出最小宽度 精度 长度12printf(&quot;%02d&quot;, x); //补0凑齐2位 输出：09 printf(&quot;%3d&quot;, x); //补空格，凑齐3位 输出：空格空格9 1) 类型 类型字符用以表示输出数据的类型，其格式符和意义如下表所示： %d 以十进制形式输出 带符号 整数 (正数不输出符号) ；补码用%d打印的时候，要算出原码来打印 printf(“%8d\\n”,100); printf(“%6d\\n”,100); printf(“%-8d\\n”,100); printf(“%+8\\n”,100); 输出结果为： └┘└┘└┘└┘└┘100 └┘└┘└┘100 100└┘└┘└┘└┘└┘ └┘└┘└┘└┘└┘100 “-“左对齐 “+”右对齐 %llu 打印 longlong unsigned 类型 （64位平台打印%d的话） %ld 长整型输出 %o 以八进制形式输出 无符号 整数 (不输出前缀0) %x 以十六进制数形式输出整数，或输出字符串的地址（只输出数字，如果要输出0x1234这样的形式的话，需要 %#x 用这种形式进行打印） %u 以十进制数输出unsigned型数据(无符号数)。注意：%d与%u有无符号的数值范围，也就是极限的值，不然数值打印出来会有误。 %c 输出一个字符 %s 输出一个字符串 %f 输出实数，以小数形式输出，默认情况下保留小数点6位,如果以 %.2f 这种写法的话，则保留小数点后2位（同理可1~6）c &#x3D; (float)a &#x2F; b;&#x2F;&#x2F;这里强制类型转换，形式结果不省略，会显示小数点后面的数 %lf 双精度浮点数时，用%f可能会丢失精度，所以用%lf更为合适 %100f 输出实数，保留小数点100位。 %e 数形式输出实数 % 根据大小自动选f格式或e格式，且不输出无意义的零 %p 打印地址 2) 标志 标志字符为 -、+、# 和空格四种，其意义下表所示： - 结果左对齐，右边填空格 + 输出符号(正号或负号) 空格 输出值为正时冠以空格，为负时冠以负号 # 对c，s，d，u类无影响； 对o类， 在输出时加前缀0； 对x类，在输出时加前缀0x； 对e,g,f 类当结果有小数时才给出小数点 3) 输出最小宽度 用十进制整数来表示输出的最少位数。若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。 4) 精度 精度格式符以“.”开头，后跟十进制整数。本项的意义是：如果输出数字，则表示小数的位数；如果输出的是字符，则表示输出字符的个数；若实际位数大于所定义的精度数，则截去超过的部分。 5) 长度 长度格式符为h、l两种，h表示按短整型量输出，l表示按长整型量输出。 计算机中的单位 2字节 — 16比特位 2^16-1 4字节 — 32比特位 2^32-1 bit — 比特位 最小，1个比特位只能装1个 1或0 byte — 字节 1个字节 &#x3D; 8个比特位的大小。 kb — 1024个byte mb — 1024个kb gb — 1024个mb tb — 1024个gb 正电 — 1 负电 — 0 二进制：（只有0和1） 10进制：0123456789 日常数字 12进制：时间（12小时一个轮回） 7进制：一周（7天一个轮回） 1234567int main()&#123; short age = 20;//向内存申请2个字节=16比特位，用来存放20这个数值 float weight = 95.6f;//向内存申请4个字节，存放小数，数值后面加f是指定95.6这个数值是float类型 char ch = &#x27;w&#x27;; return 0;&#125; 变量和常量 常量：圆周率、身份证号..不变的值 变量：年龄、体重..可变的值，C语言中变量有两个不同类型（局部变量，全局变量） 变量1234567891011#include&lt;stdio.h&gt;int num1 = 20;//全局变量-定义在代码块&#123;&#125;之外的变量int num2; //一个全局变量不给初始化的话,默认会被初始化为0;int main()&#123; int num1 = 10;//局部变量-定义在代码块&#123;&#125;内部的变量 ;名字相同的话，把这行去掉就直接显示全局 int a; //一个局部变量不给初始化的话,默认是随机值 printf(&quot;%d\\n&quot;, num1);//局部和全局变量的名字尽量不要相同，容易误会出bug； //当局部和全局变量名字相同时，局部优先显示。 return 0;&#125; 计算两个数值的和 关于scanf函数报错 在项目最开头处加上：#define _CRT_SECURE_NO_WARNINGS 112345678910111213141516171819#define _CRT_SECURE_NO_WARNINGS 1#include&lt;stdio.h&gt;int main()&#123; int num1 = 0; int num2 = 0; int sum = 0; //C语言语法规定，变量要定义在当前代码块的最前面 /*输入数据-使用输入函数scanf vs2019中加(_s) scanf_s() 的功能虽然与scanf() 相同，但却比 scanf() 安全， 因为 scanf_s() 是针对“ scanf()在读取字符串时不检查边界，可能会造成内存泄露”这个问题设计的。 scanf_s()用于读取字符串时，必须提供一个数字以表明最多读取多少位字符，以防止溢出。 【scanf_s()】这个只能用于vs，其他软件不兼容，缺乏跨平台性，所以尽量不用， 在源文件最前面加上#define _CRT_SECURE_NO_WARNINGS 1 这样就可以让编译器不报错*/ scanf(&quot;%d%d&quot;,&amp;num1,&amp;num2);//取地址符号&amp; scanf输入的值太大的话，还是会硬塞入内存中，导致溢出 sum = num1 + num2; //scanf不会关心目标空间到底放不放得下 printf(&quot;sum=%d\\n&quot;, sum);//%d前面的（sum=）会在调试中显示出来 return 0;&#125; while(scanf(“%d”,&amp;a) &#x3D;&#x3D; 1) &#x2F;&#x2F;scanf成功读取到输入信息时,返回值为1 ;如果无法读取输入信息时,返回值为EOF EOF值为-1while(scanf(“%d”,&amp;a) !&#x3D; EOF) 退出程序按 ctrl + z 变量的作用域1234567891011121314151617181920#include&lt;stdio.h&gt;int global = 2020;//全局变量的作用域是整个工程void test()&#123; printf(&quot;test()--%d\\n&quot;, global);//这里不运行，只是声明&#125;int main()&#123; &#123; int num = 0; //局部变量的作用域是，局部变量坐在的&#123;&#125;里面才起作用， printf(&quot;num=%d\\n&quot;, num);//如果把printf(&quot;num=%d\\n&quot;, num);移到变量int num = 0;的&#123;&#125;以外，不起作用 &#125; printf(&quot;global=%d\\n&quot;, global); test();//在main里调用了void函数，所以会执行 //在同一个工程中，不同的源文件里有一个全局变数int g_val = 2021; //声明 extern外部符号的(其他源文件里的全局变数) extern int g_val; printf(&quot;g_val=%d\\n&quot;, g_val); //这时就会显示g_val = 2021 return 0;&#125; 变量的生命周期局部变量的生命周期是在{}里面的，而全局变量的生命周期则是整个程序的生命周期 12345678910#include&lt;stdio.h&gt;int main()&#123; &#123;//生命周期开始 int a = 10; printf(&quot;a=%d\\n&quot;, a);//ok &#125;//生命周期结束 printf(&quot;a=%d\\n&quot;, a);//error(错误) return 0;&#125; 常量（字面常量）（const修饰的常变量）const - 常属性 123456789101112131415#include&lt;stdio.h&gt;int main()&#123; //const-常属性， //const int n = 10;//n是变量，但是又有常属性，所以我们说n是常变量 //int arr[10] = &#123; 0 &#125;;//数组[]中必须用常量数值才能运行，不可以用常变量代替 const int num = 4;//int num是把num定义为4，属于变量，前面加上const,变成const修饰的常变量 printf(&quot;%d\\n&quot;,num); num = 8;//前面int num=4是变量，可运行。但是加const变成常变量时，num=8就会error printf(&quot;%d\\n&quot;, num); 3;//字面常量 3.14;//字面常量 return 0;&#125; 常量（#define定义的标识符常量）123456789#include&lt;stdio.h&gt; //#define 定义的标识符常量 (define宏定义）#define MAX 10 //定义一个常量叫MAX的符号，后面10是定义为10的意思int main()&#123; int arr[MAX] = &#123;0&#125;;//用定义符定义的常量，可以在数组[]中使用 printf(&quot;%d\\n&quot;, MAX); // 输出10 return 0;&#125; 常量（枚举常量）（例1：）12345678910111213141516171819//枚举常量//枚举-一一列举（性别：男，女，保密。三原色：红，黄，蓝。）//枚举关键字 - enumenum Sex //性别,英文：男，女，保密&#123; MALE, FEMALE, SECRET&#125;; //MALE,FEMALE,SECRET这3个值-枚举常量#include&lt;stdio.h&gt;int main()&#123; //enum Sex s = MALE;//名叫s的人是男的 enum Sex s = MALE;//枚举取值只能取设定好的值:只能是MALE,FEMALE,SECRET其中一个 printf(&quot;%d\\n&quot;, MALE);//枚举常量是有值的，且默认顺序为0，1，2...并且不可被改变 printf(&quot;%d\\n&quot;, FEMALE); printf(&quot;%d\\n&quot;, SECRET); return 0;&#125; （例2：）12345678910111213enum Color //颜色，红黄蓝&#123; RED, YELLOW, BLUE&#125;;int main()&#123; enum Color color = BLUE;//名称为color的颜色为蓝色BLUE color = YELLOW;//这个color只是某物品名称，是变量，可以被改 //BLUE = 6;//这个是枚举定义的常量，必须按默认0，1，2...颜色本身不能被改，所以error return 0;&#125; 字符串字符串 — 由””括起来的字符‘\\0’ — 转义字符 — 0 1234567891011121314151617#include&lt;stdio.h&gt; // 0-数字0int main() // &#x27;0&#x27;--&gt;字符0，ASCII值：48&#123; char arr1[] = &quot;abc&quot;;//数组 //&quot;abc&quot;相当于&#x27;a&#x27;&#x27;b&#x27;&#x27;c&#x27;&#x27;\\0&#x27;------&#x27;\\0&#x27;字符串结束标志 char arr2[] = &#123; &#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;\\0&#x27;&#125;; //&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;只有&#x27;a&#x27;&#x27;b&#x27;&#x27;c&#x27;,没有结束标志。所以用&#123;&#125;打字符串时，要加入&#x27;\\0&#x27;或者0，代表字符结束。 printf(&quot;%s\\n&quot;, arr1);//打印字符串用%s printf(&quot;%s\\n&quot;, arr2);//没有遇到\\0的话,会一直往后面读取,导致报错 &quot;hello bit&quot;; &quot;&quot;;//空字符串 return 0; //数据在计算机上存储的时候，存储的是2进制 //每个字符都有它们对应的值#aA$hud... 比如：a-97 A-65 \\0-0 ... //ASCII 编码，每个字符都有ASCII码 //ASCII 码值，每个ASCII码对应的值&#125; 计算字符串长度 strlen();12345678910#include&lt;stdio.h&gt;#include&lt;string.h&gt; //strlen函数的头文件（计算长度的头文件）int main()&#123; char arr1[] = &quot;abc&quot;;//长度：3 char arr2[] = &#123; &#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;//长度：不加\\0，结果为随机值；加上&#x27;\\0&#x27;后，长度为3。 printf(&quot;%d\\n&quot;, strlen(arr1));//strlen - string length - 用来计算字符串长度的 printf(&quot;%d\\n&quot;, strlen(arr2)); return 0;&#125; 这里的\\0是转义字符，转义字符的意思是-在字符前面加上’&#39;，从而改变字符原有的意思。 比如：’\\n’-从字面’n’变为’换行’的意思， ‘\\t’ –&gt; ‘水平制表符’， ‘\\r’ –&gt; ‘回车’….. (详细请看下面转义字符规律图表) 转义字符 转义字符 意义 ASCII码值（十进制） \\a 响铃(BEL),警告字符 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 \\\\ 代表一个反斜线字符’\\‘ 092 \\‘ 代表一个单引号（撇号）字符 039 \\“ 代表一个双引号字符 034 \\? 代表一个问号, 防止识别为三字母词(are you ok??)&#x3D;&gt;(are you ok] ??) &#x3D;&gt; ] 063 \\0 空字符(NUL) 000 \\ddd ddd表示1~3个八进制的数字 三位八进制 \\xdd dd表示2个十六进制数字 十六进制 例：123456789#include&lt;stdio.h&gt;int main()&#123; printf(&quot;c:\\\\2013\\\\music\\\\zhou.mp3&quot;);//为防止系统把&#x27;\\&#x27;理解为转义字符，把&#x27;\\&#x27;写作&#x27;\\\\&#x27; //这时得到的结果是c:\\2013\\music\\zhou.mp3这样的地址 printf(&quot;%c\\n&quot;, &#x27;\\&#x27;&#x27;);//同理：&#x27;--&gt;\\&#x27; 才能打出符号&#x27; printf(&quot;%s\\n&quot;, &quot;\\&quot;&quot;);//字符串也是同理 return 0;&#125; ‘\\ddd’ 8进制1234567891011121314#include&lt;stdio.h&gt;#include&lt;string.h&gt; //计算长度的头文件int main()&#123; printf(&quot;%d\\n&quot;, strlen(&quot;c:\\test\\32\\test.c&quot;));//长度为13，但是为什么是13呢 \\t算一个字符 printf(&quot;%c\\n&quot;, &#x27;\\32&#x27;);//显示&quot;→&quot; //\\32 -- 32是2个8进制数字 （不能出现8，9这种超过7的数值） 3*8^1+2*8^0 = 24+2 =26 26在ASCII码中是&#x27;→&#x27; //32作为8进制--&gt;10进制数字，10进制--&gt;ASCII码值对应的字符 //32--&gt;10进制 26-&gt;作为ASCII码值代表的字符 printf(&quot;%c\\n&quot;, &#x27;\\132&#x27;);//显示&#x27;Z&#x27; // 八进制算法：\\132 -- 1*8^2+3*8^1+2*8^0 = 64+24+2 = 90 --&gt; ASCII码值为：&#x27;Z&#x27; //所以\\32是一个字符&#x27;→&#x27; return 0;&#125; ‘\\xdd’ 16进制123456#include&lt;stdio.h&gt;int main() // &#x27;\\&#x27;后面的只是数字：8进制；如果是&#x27;\\x&#x27;加数字：16进制。&#123; printf(&quot;%c\\n&quot;, &#x27;\\x61&#x27;);//十六进制算法：\\x61 -- 6*16^1+1*16^0 = 96+1= 97 --&gt; ASCII码值为：&#x27;a&#x27; return 0;//把16进制换成10进制,然后对应相对应的ASCII码值.&#125; 注释 C语言风格：&#x2F;*xxxxxxxx*&#x2F; 缺点：不支持嵌套(&#x2F;*xxxx&#x2F;*xx*&#x2F;xxxx*&#x2F;)后面一部分不被注释 C++风格：&#x2F;&#x2F;xxxxxxxxxx 可以注释一行也可以注释多行（推荐用这种） 选择语句123456789101112131415#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; int input = 0; printf(&quot;在大学里\\n&quot;); printf(&quot;你要好好学习吗？请输入(1,0)&gt;:&quot;); scanf(&quot;%d&quot;, &amp;input); //输入函数，选择输入1/0 if (1 == input) //if-如果 一个&#x27; = &#x27;表示赋值，两个&#x27; = &#x27;表示判断是否相等。 printf(&quot;好offer\\n&quot;); //else //else-其他 if (0 == input) //这种也可以用 printf(&quot;卖红薯\\n&quot;); return 0;&#125; 循环语句 while语句 for语句 do…while语句while例：123456789101112131415#include&lt;stdio.h&gt;int main()&#123; printf(&quot;在大学里\\n&quot;); int line = 0; while (line &lt; 20000) &#123; printf(&quot;敲一行代码:%d\\n&quot;,line); line++; //使变量的值增加1 同理&#x27;--&#x27;使值减1 &#125; if (line &gt;= 20000) //一直循环，直到&gt;或=20000 printf(&quot;好offer\\n&quot;); return 0;&#125; （本篇未完，请继续浏览《C语言的初次见面-下》） 参考文献 https://github.com/soukenki","categories":[{"name":"C语言","slug":"C语言","permalink":"https://soukenki.github.io/zh-CN/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语法","slug":"C语法","permalink":"https://soukenki.github.io/zh-CN/tags/C%E8%AF%AD%E6%B3%95/"}]},{"title":"初次见面，我的第一篇文章","slug":"初次见面，我的第一篇文章","date":"2022-11-22T15:45:05.000Z","updated":"2022-11-22T16:09:11.866Z","comments":true,"path":"2022/11/23/初次见面，我的第一篇文章/","link":"","permalink":"https://soukenki.github.io/zh-CN/2022/11/23/%E5%88%9D%E6%AC%A1%E8%A7%81%E9%9D%A2%EF%BC%8C%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","excerpt":"目录 自我介绍 目标 分享 我的代码库","text":"目录 自我介绍 目标 分享 我的代码库 自我介绍大家好，我叫曹建熙。这是我的个人博客，我会在这里分享我学习代码时的理解和心得。 现在是在日本的留学生，学习计算机知识。性格乐观开朗，爱好是旅行、美食、音乐、钓鱼等。 大家如果有什么建议或者疑问，都可以通过邮件、微信或者line联系我。 目标活到老学到老，希望自己可以一直坚持学习。不断提高自己的技术水平，向大牛们学习。 分享最后分享一些旅行和美食的照片。 瑞龙寺 高冈大佛 和牛牛排 我的代码库 https://github.com/soukenki","categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://soukenki.github.io/zh-CN/tags/%E6%9D%82%E8%B0%88/"}]}],"categories":[{"name":"C语言","slug":"C语言","permalink":"https://soukenki.github.io/zh-CN/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语法","slug":"C语法","permalink":"https://soukenki.github.io/zh-CN/tags/C%E8%AF%AD%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"https://soukenki.github.io/zh-CN/tags/%E9%A2%98%E8%A7%A3/"},{"name":"杂谈","slug":"杂谈","permalink":"https://soukenki.github.io/zh-CN/tags/%E6%9D%82%E8%B0%88/"}]}